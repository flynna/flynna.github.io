---
title: Javascript 作用域理解
date: 2022-08-04 21:34:45
updated: 2022-08-04 21:34:45
tags:
  - javascript
  - 作用域
categories:
  - 技术分享
  - JavaScript
---

### 什么是作用域？

域：范围、区域

作用域：变量起作用的一个域 --> 变量起作用的一个范围

那么，在`js`中的作用域又是怎么设定的呢？直接写在`script`脚本的最外层和写在函数体内又有啥不同？

<!-- more -->

### 作用域分类

在`es5 即 ECMAscript5`根据范围的不同，作用域分为了**全局作用域**和**局部作用域**。**这个标准中只有函数拥有局部作用域。**

在`es6 中新增了块作用域。`

#### 全局作用域

在全局作用域下声明的变量就是全局变量。而**全局作用域是唯一的，只有一个**。

你可以理解为： `<script>`标签下的最外层变量或者函数、以及**所有能够在`js`代码的任何地方能够访问的对象拥有全局作用域。**，那么不难得知：**`window`对象拥有全局作用域。**

例如代码：

```html
<script>
  var a = 'test';

  function fn1() {
    var b = 1;

    c = {};
  }

  var d = function () {
    var f = true;
  };
</script>
```

在这个代码片段中，变量`a`、函数`fn1，d`、属性`c（为什么是属性？）`，均能够在代码的任何地方进行访问（也是‘所谓的’处在最外层），都处在同一个全局作用域中。`fn1 中的 c 会不断向上寻址，直到全局作用域，如果没有任何 var 声明，那么它的赋值则会被当做是 window 的外挂属性进行设置并赋值，让使用者产生了一种不用声明的假象。`

#### 局部作用域（私有作用域）

`es5`标准中，只有函数有私有作用域。在函数体内定义的一切变量和函数，影响范围和可访问范围仅在函数体内，如上面代码片段中的变量`b 和 f`。

> **每个函数都有一个独立的私有作用域。**

#### **块级作用域**

##### **why?**

这个是`es6`提出的概念，那么为什么需要块作用域？

> 块作用域的出现，避免了内存泄漏，例如下面代码：用来计数的循环变量泄露为全局变量

```javascript
for (var i = 0; i < 10; i++) {
  // ...
}
```

> 预解析导致的误判，误判外层变量被覆盖。~~（这个问题我认为影响还没那么大，毕竟只要写的够规范，就不存在）~~

```javascript
var i = 1;

function fn() {
  i *= 10; // NaN

  if (true) {
    var i = 20;
  }
}

fn();
console.log(i);
```

大家可以猜一下结果，我先说错误答案：~~`10, 20`~~，相信有一部分同志已经绕进去了。

其实细看，在代码运行到`fn()`时，开始对`fn`函数体进行预解析，这个过程也可以理解为‘变量提升’，然后再开始执行函数体代码，此时的`i *= 10`其实是对局部变量的赋值操作。说到这就不难发现，此时的全局变量`i`值为`1`。

##### 定义和规范

任何`{}`包裹的代码都可以称之为块，而包裹在内的变量都会受块作用域的影响。而让这个块作用域生效的，正是`let 和 const`。

通过`let`和`const`声明的变量，无法在块的外部访问。而两者的区别，就是`let`的值可以被修改，`const`定义的是常量，无法被修改。

与`var`的区别：

> **let 和 const 声明的变量，不会被提前预解析，没有所谓的变量提升特性，而是‘暂时性死区（temporal dead zone）’特性**。

> **let 和 const 声明的变量，仅在‘块作用域’中生效。**

### 作用域变量的访问规则（**变量提升**）

> 要使用某个变量，会先在自己的作用域里查找，如果找到，那就直接使用（**如果使用这个变量的语句在声明它之前，那么此时使用的这个变量值为 undefined，同时应该注意：只有 var 声明的变量允许在声明前访问**），如果找不到，就往上一级查找，如果找到，就直接拿来用，如果还是找不到，再继续... 往上一级查找，直到全局作用域。 如果最终找到，那就直接用，找不到那就报错 xxx is not defined.

> 变量查找，只能往上查找，不能往下。

总结就是：**全局不能访问局部，局部可以拿到全局。**

```javascript
let n = 10,
  m = 20;

function fn2(n) {
  console.log(n); // 15
  console.log(m); // 20
}

fn2(15);
```

`n`会优先从局部变量读取，`m`局部没有声明，向上寻址，在全局作用域中找到。

### 作用域变量的赋值规则

注意：**赋值的这个变量的寻址过程需要遵循作用域变量的访问规则**。

> 如果自己的作用域，有这个变量，那么直接给自己作用域的这个变量赋值。

> 如果自己的作用域没有这个变量，那就往上一级查找，如果找到，那就赋值，如果没有找到，就继续往上一级查找...直到全局作用域，如果找到，那就赋值，找不到就会被当做是 window 的一个属性，并进行赋值。

**注意这个寻找的过程，只有 var 变量允许在声明之前赋值，let 不允许。**

### 作用域变量的生命周期

`就是作用域变量在内存之中存活的时间。`

> 全局变量：生命周期是和程序同步的， 程序不关闭，变量就一直存在。

> 局部变量：生命周期是和函数执行同步的，函数执行结束变量就被删除了。

> 块作用域变量：仅存活与块代码执行时，执行结束内存就会释放。

综上，全局变量的大量使用会导致程序变得更重。如果代码逻辑写的不够严谨，很容易造成内存泄漏吗（例如：不声明变量直接赋值，会挂载到 window 对象），影响到我们程序的运行效率。~~如果可能，还是少设计一点全局变量吧！对大家都好...hh~~

> 建议：任何一个独立的 script 标签下的代码，都应用匿名函数包裹，并自调用。避免污染全局，并造成其他未知的程序错误。

例如：

```javascript
(function () {
  // ...
})();

// 或者：这是自调用的几种写法，推荐用上面那种，下面的仅做了解
~function () {};
!function () {};
+function () {};
```
