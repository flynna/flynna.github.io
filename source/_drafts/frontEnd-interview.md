---
title: 高级前端题库：你没见过的八股文都在这
date: 2024-04-12 11:17:42
updated: 2024-04-12 11:17:42
tags:
  - interview
categories:
  - 技术分享
---

一些你见过的...没见过的...八股文...~~实际开发中哪里会遇到这些问题呢？可能会有，但不常见。但你又不能不知道🙄🙄🙄~~

文章包括了 `css`、 `js`、 `ts`、 `node`、 `框架`、 `工程化`、 `浏览器`、 `HTTP 网络以及安全`、 `算法题`、 `项目`、`手写题` 多个维度..._不排除后面会更新其他的类型_

因为是汇总的问答篇，所以描述也并不会很详细（如果是要学习的话，鼓励去刨根问底，知其然知其所以然...）

持续更新...涨知识中...

<!-- more -->

## CSS 篇

### BFC 以及其应用

> BFC 块级格式上下文：决定元素如何布局，以及和其他元素之间的关系和作用。通俗讲，BFC 的元素的布局是不受外界的影响的。

触发：

- `float` 值不为 `none`
- `position` 值不为 `static` 和 `relative`
- `display` 值不为 `none`
- `overflow` 值不为 `visible`

应用：

- 清除浮动
- 防止垂直 margin 重叠
- 防止文字环绕
- 防止元素被浮动元素覆盖

### BFC/IFC/GFC/FFC 区别

### 怪异盒模型

> 常规盒模型：`盒子总宽 = width + padding + border + margin`
> 怪异盒模型：`盒子总宽 = width + margin`

触发：

> 标准盒模型：`box-sizing: content-box`
> 怪异盒模型：`box-sizing: border-box`

### CSS 预处理器

> CSS 预处理器所做的本质上是为 CSS 增加一些可编程的特性，通过变量、嵌套、简单的程序逻辑、计算、函数等特性，通过工程化的手段让 CSS 更易维护，提升开发效率

### 自适应实现

> 媒体查询、相对单位 rem/em/vw/vh/百分比....

### 垂直居中的几种实现方案

## JS 篇

### 垃圾回收

概念：

- **对于开发者而言，“不再需要的”内存被称为垃圾**，而“不再需要”的定义又太过主观，这取决于开发者。`JS` 语言提供了垃圾回收器，尽管它无法断定“不再需要的”内存是否需要回收，但**对垃圾回收器而言，无法触达的内存空间（即不再可访问），它一定是垃圾，需要被回收。**
- 除了回收器**自动识别无法触达**来回收垃圾释放内存外，还可以通过**将变量或函数置为 `null`** 的方式让其之前的内存空间不可达来**触发垃圾回收**。

实现（回收器如何判断是否可触达）`GC（垃圾回收）` 算法：

`所谓的标记，其实就是在进入执行上下文时开始标记，出执行上下文时结束标记，记录存活的对象并标记`\_`

- **引用计数**：`IE9 以下`

  1. 给对象添加一个引用计数器，每当有一个地方**引用它时，计数器值就 `+1`**，当**引用失效时，计数器值就 `-1`**。任何时刻**计数器为 `0` 的对象**即表示不可能再被访问了，因此**可以回收**。

> 缺点: 当**对象循环引用时，引用次数无法标记为 `0`**，就会导致无法被回收。

- **标记清除**：`JS` （浏览器）最常用得到垃圾回收机制。
  1. 标记阶段：垃圾回收器将所有**活动对象（从根节点开始的可达对象）做上标记**，然后遍历堆中的所有对象，**清除没有标记的对象（垃圾）**
  2. 清除阶段：**清除没有标记的对象，释放内存**

> 优缺点：标记清楚法只需要记录起始和结束过程中的活动对象，所以**速度快**。然而由于清除的对象空间不连贯，在清除后并不会对空出来的空间进行整理，因此会**产生大量不连续的内存碎片**，导致无法分配较大的对象，**造成内存溢出**。

- **标记整理**：
  1. 标记阶段：同**标记清除**。
  2. 整理阶段：将所有**活动对象压缩（移动）到内存的一端**，然后**清理边界外的内存**。

> 优缺点：和标记清除相比，多了将活动对象移动到内存一端的过程，所以**速度慢**。此外**避免了不连续的内存碎片产生**，能更好的利用内存空间。

- **复制**：
  1. 将内存分为大小相等的两块`（1，2）`，每次只使用其中一块。
  2. 在垃圾回收时，将所有存活的对象`（1）`复制到未使用的那块内存`（2）`中，然后清除正在使用的内存`（1）`中所有对象。

> 优缺点：因为需要将内存一分为二，所以会**占用双倍的内存空间**，优点同标记整理，**避免了不连续的内存碎片产生**。

- **分代收集**：
  1. 把堆内存分为**新生代**和**老生代**（详细比例看不同语言实现）。
  2. **新生代**中，每次垃圾回收后，都会发现有大批对象死去，只有少量对象存活，那么就采用**复制算法**，只需要少量的内存成本就可以收集。（新生代分为**三个区：Eden、From、To**。当空间不足时会触发 `GC`，`Eden` 和 `From` 区存活的对象将复制到 `To` 区，`存活值 +1`，然后清除 `From` 区空间，再交换 `To` 区和 `From` 区，直到下一次 `GC`。存活值超过阈值`默认 15`的活动对象，放入老年代中，当**老年代空间不足先触发 `GC`**，还是不足则触发 `Full GC`，之后还不足则抛出**栈溢出**）
  3. **老年代**中，因为对象存活率高、没有额外空间对它进行分配担保，就必须使用**标记整理**算法来进行垃圾回收。

> 优缺点：根据活动对象的存活时间，采取不同的回收策略，最大化提升回收效率。

---

### 内存泄漏

概念：

- 内存泄漏是指**不再需要使用的内存，没有及时得到释放，造成的内存浪费，使程序内存占用越来越高影响性能**。

如何定位（发现）：

> `浏览器的DevTools/Memory` 提供了页面活动情况生成可视化结果，对比内存堆栈变化确认是否产生内存泄漏

- 打开 `devtools`，切换到 `memory tab` 页。
- 打开**录制生成快照**（会记录此时的内存占用），此时**执行**一些你认为会导致内存泄漏的**操作**。
- **点击**录制旁边的**垃圾回收**（看着有点像删除按钮），然后**重新点击录制生成快照**。
- **对比**两次**内存占用**，判断是否产生了内存泄漏

解决（如何避免内存泄漏）：

- **减少不必要的全局变量，及时释放不再使用的对象**。包括但不限于 `dom 引用`、`事件监听` 等等。

- **减少闭包的使用**，至于闭包为何会造成内存泄漏，下面在闭包中详谈。

---

### 闭包的理解

概念：

- 函数嵌套函数，内部的函数就是闭包。

优缺点：

- 空间私有化，持久化内存，延长变量的生命周期。

- 可以从函数外部访问到函数内部的变量。

- 容易造成内存泄漏：
  1. 持有了不再需要的函数引用，会导致函数关联的词法环境无法销毁，从而导致内存泄漏
  2. 当多个函数共享词法环境时，会导致词法环境膨胀，从而导致无法触达也无法回收的内存空间造成内存泄漏。

如何解决闭包的内存泄漏:

- **尽量避免使用闭包**；

- **在使用完后将其置为 `null` 触发 `GC`**。

应用：

- 防抖节流函数实现，`react hooks` 实现等。

---

### New 操作符作用以及实现原理

作用：生成类的**实例对象**，或者构造函数的实例对象。

实现：

- 创建一个新对象；
- 将新对象与构造函数通过原型链关联起来；
- 将构造函数中的 `this` 绑定到这个新对象上；
- 根据构造函数返回值类型判断，如果返回值是一个对象，则正常处理，否则返回这个新对象。

模拟实现：

```js
function _new(fn, ...args) {
  const obj = {};
  obj.__proto__ = fn.prototype;
  const result = fn.apply(obj, args);
  return result instanceof Object ? result : obj;
}
```
---

### 如何确保构造函数只能通过 new 调用

- 通过判断 this(new 调用时会指向实例) 是否为当前构造函数的实例(instanceof)。 **`this instanceof Fn`**
- 借助 **new.target 判断是否通过 new 调用**
- **ES6 的 class**

---

### 原型链

概念：

- 所有的**对象都有一个属性 `__proto__`**，所有的**函数都有一个属性 `prototype`**
- 对象的`__proto__` 指向其构造函数的 `prototype`。
- 构造函数的 `prototype` 本身也是一个对象（**原型对象**），它有一个属性 `constructor` 指向构造函数本身。

为什么称为原型链：

> 正是因为构造函数的 `prototype` 也是一个对象，所以它可以通过 `__proto__` 找到上层构造函数，一直向上直到为 NULL，因此就**形成了链式访问，称之为原型链**。

---

### this 理解和指向修改

_根据不同的环境以及执行上下文决定当前的 this。_

- 在浏览器全局环境中为 window，如果是别的**全局环境可以使用 `globalThis` 来获取**。

- 如果是**函数执行上下文**，判断是箭头函数还是具名（匿名）函数。
  - 如果是**箭头函数，其本身不含 this**，所以在它里面访问 this 会**向上(词法环境)查找**。
  - 如果是**具名（匿名）函数，则和它的调用者有关**。（**直接调用**指向全局 this，**对象.方法** 则指向对象，类推如果是事件绑定：**事件源.事件** 则指向事件源）

修改：

- 通过 `fn.call/fn.apply/fn.bind` 都可以修改 this 指向
- 都是通过调用时传入第一个参数来修改 this，这个参数就是新的 this
- 区别就是 call/apply 都是立即执行该函数，而 bind 则是会返回一个新的函数(如果传了函数参数，会在调用新函数时作为预置参数，排在其他参数之前)，并不会产生副作用。
- 除此之外，call/bind 除了第一个参数位置外，其他函数参数格式都是以此传入，而 apply 则是以数组形式传入。

---

### 变量提升（预解析）/暂时性死区（TDZ）、执行上下文（词法环境）、作用域链理解

**变量提升（预解析）/暂时性死区（TDZ）**:

- 在代码执行前，会经历一次**预解析**过程，会**优先进行函数/变量的声明/提升**。
- 提升后，如果在其真正**声明(实际代码位置)前访问**，会根据声明关键字不同而产生不同的表现。
  - 如果是 **`var` 则会返回 `undefined`**
  - 如果是 **`let/const` 则会报错**。（根据官方说明：这两个关键字声明的变量，在其真正**声明前的区域**访问会抛异常，这块区域**也称 `TDZ暂时性死区`**）
  - 如果是 **`function`**，则返回函数，可以正常执行（**提升过程中如果遇到同名声明**（不分先后顺序），**函数优先级最高**，即在**同名声明(代码位置)之前访问(打印)返回函数**，同名声明**之后返回新的声明值**（它俩的排列**先后顺序不影响结果**）**）

**执行上下文**：

- 又称**执行环境**。分为**全局执行上下文**和**函数执行上下文**。
  - 全局执行上下文：**在程序开始执行时创建**，只有一个，即**全局执行上下文**。
  - 函数执行上下文：**在函数被调用时创建**，每次函数调用都会产生一个新的上下文，即**函数执行上下文**。

**作用域链**：

> 作用域：分为全局作用域、局部(私有，目前只代表函数)作用域、块级作用域(`let/const` 只在这个作用域生效，一个 `{}` 就是一个块作用域)

- 所谓的作用域链，是我们在访问某个变量时，会优先在当前作用域查找。如果没有找到，则是会在上一层级的作用域进行查找(访问)，一直向上直到最顶层。

---

### 事件循环（node 和浏览器的区别）

之前写了一篇文章单独整理了。[https://flynna.github.io/share/javascript-event-loop/?t=1712848978855](https://flynna.github.io/share/javascript-event-loop/?t=1712848978855)

**为什么存在**（需要）事件循环：**`JS` 是单线程**，而有些任务需要长时间挂起，为了**避免程序被阻塞**产生同步和异步任务。事件循环就是**协调这些任务**排列处理的一种方式。

> 执行宏任务 —> 然后执行宏任务产生的微任务 —> 若微任务在执行过程中产生了新的微任务（加到队列末尾），则继续执行微任务 —> 微任务执行完毕清空 —> 下一个符合条件的宏任务进行下一轮循环…..

**node 和浏览器中的事件循环区别**:

- 前面提到的都是浏览器中事件循环的表现（**Node 在 11 版本后行为和浏览器一致**）。

- 针对 `node 环境（10 以前）`：
  - `process.nextTick()` 的优先级要高于其他微任务。而浏览器环境中是同优先级，看入队列的先后顺序
  - node环境下有六个阶段的宏任务（`timers定时器`、 `pending callback回调`， `idle，prepare 系统内部使用`， `poll 轮询`， `check 检测，setImmediate 在这个阶段执行`， `close callbacks 关闭的回调 .on('close', callback)`），执行完一个阶段的任务后，会先执行 `process.nexTick()`，然后执行微任务队列，然后执行下一个阶段任务...

---

### 继承的几种实现方式

详见：[https://flynna.github.io/share/javascript-extends](https://flynna.github.io/share/javascript-extends)

### 模块化和模块化规范（历程）

### 防抖、节流实现

概念：

- 防抖：**在事件被触发 n 秒后再执行回调，如果在这 n 秒内又被触发，则重新计时**。
- 节流：**规定一个单位时间，在这个单位时间内，只能有一次触发事件的回调函数执行，如果在同一个单位时间内某事件被触发多次，只有一次能生效**。

实现：

- 防抖：
  - 利用 `setTimeout` 设置一个定时器，在定时器时间内，事件被触发，则清除之前的定时器，重新设置一个定时器。
- 节流：
  - 利用 `setTimeout` 设置一个定时器，在定时器时间内，事件被触发，则不执行回调函数，直到定时器时间结束，执行一次回调函数。

---

### 深拷贝和浅拷贝

概念：

- 浅拷贝：**只拷贝一层**，更深层次的对象，只是拷贝其引用地址**。
- 深拷贝：**拷贝多层**，每一级别的数据都会拷贝。

实现：

- 浅拷贝：
  - `Object.assign()`
  - `展开运算符`
  - `Array.prototype.concat()`
  - `Array.prototype.slice()`
  - ...
- 深拷贝：
  - `JSON.parse(JSON.stringify())`
  - `lodash.cloneDeep()`
  - ...

---

### promise 间隔输出实现

- 封装一个返回 promise 的函数，promise 内部添加 setTimeout 控制输出并 resolve
- 外层通过 for...of 循环 await 输出即可

---

### promise 实现原理、相关 api 手写

### promise link（promise A+ 规范）

> 值是对象或者函数，并且拥有 then 方法实现。

```js
function isPromise(value) {
  return value !== null && (typeof value === 'object' || typeof value === 'function') && typeof value.then === 'function';
}
```

### es7 的 async/await 原理和实现

可以看作是**自带启动器**的基于 **`generator 函数`实现**的**语法糖**。

---

### 迭代器及实现原理

> 迭代器可以通过 next() 方法实现的迭代器协议的任意一个对象，并返回 value 和 done 属性。

通俗的说，任意一个**对象**都可以**通过迭代器协议**，**实现为可迭代对象**。

实现：

- 给对象添加 `Symbol.iterator` 属性，并指向一个迭代器函数。
- 在迭代器函数中，返回一个对象，包括 next 方法和 `return 方法(可选，用于关闭)`
- next 方法需要返回一个对象，包括 value 和 done 属性。

```js
const obj = {};
obj[Symbol.iterator] = function() {
  const _this = this;
  let index = 0;
  return {
    next() {
      const keys = Object.keys(_this);
      index++;
      return {
        value: _this[keys[index]],
        done: index = values.length;
      };
    }
  }
}
```

---

### Symbol、bigInt 类型了解

- Symbol 类型：**用于创建唯一标识符**，**防止属性名冲突**。
- bigInt 类型：在一个整数字面量后面加 n 的方式定义一个 BigInt，表示任意大小的数字，调用函数 BigInt()【不需要 new】。

---

### requestAnimationFrame 和定时器（setTimeout/setInterval）的区别

> 浏览器**定时器**的一种优化，**在屏幕刷新期间执行**，**保证动画流畅**。

- 浏览器**定时器**：
  - `setTimeout`：在指定的毫秒数后执行注册的函数，只执行一次。
  - `setInterval`：每隔指定的毫秒数执行注册的函数，**无限次**。
  - 在事件队列（延时队列）中排队执行
- `requestAnimationFrame`：
  - 浏览器**定时器**的一种优化，**在屏幕刷新期间执行（必定会执行，和浏览器是否空闲无关）**，**保证动画流畅**。

---

### IntersectionObserver 和 MutationObserver 了解

- `IntersectionObserver`：**用于检测目标元素是否可见**，**在目标元素与视口产生交集时触发回调函数**。

> IntersectionObserver **是异步的，也是惰性的**，意味着只有当检测目标的**可见性发生变化**才会通知**执行回调**

- `MutationObserver`：**用于检测 DOM 变动**，**在 DOM 发生变化时触发回调函数**。

---

### map、set、weakMap、weakSet 区别

set：

- 成员不能重复
- 只有健值，没有健名，有点类似数组。
- 可以遍历，方法有 add, delete, has

weakSet

- 成员都是对象
- 成员都是弱引用，随时可以消失。可以用来保存DOM节点，不容易造成内存泄漏
- 不能遍历，方法有add, delete, has

Map

- 本质上是健值对的集合，类似集合
- 可以遍历，方法很多，可以干跟各种数据格式转换

weakMap

- 直接受对象作为健名（null除外），不接受其他类型的值作为健名
- 健名所指向的对象，不计入垃圾回收机制
- 不能遍历，方法同 get,set,has,delete

### proxy 和 reflect 常用 API 理解和使用

> **proxy：用于创建一个对象的代理，从而实现基本操作的拦截和自定义**（例如：Vue3 使用 proxy 做数据劫持）

- 语法：`const proxy = new Proxy(target, handler)`
- 参数：
  - target：要拦截的目标对象
  - handler：一个对象，用来定制拦截行为
- 拦截行为：
  - get(target, propKey, receiver)：拦截对象属性的读取
  - set(target, propKey, value, receiver)：拦截对象属性的设置
  - has(target, propKey)：拦截 propKey in proxy 的操作，返回一个布尔值
  - deleteProperty(target, propKey)：拦截 delete proxy[propKey]的操作
  - ownKeys(target)：拦截 Object.getOwnPropertyNames(proxy)、Object.getOwnPropertySymbols(proxy)、Object.keys(proxy)、for...in 循环，返回一个数组。该方法返回目标对象所有自身的属性的属性名，而 Object.keys()的返回结果仅包括目标对象自身的可遍历属性。
  - ...

> **reflect：是一个内置的对象，它提供`拦截 JavaScript 操作`的方法。**

总结：`对于每个可被 Proxy 捕获的内部方法，在 Reflect 中都有一个对应的方法，其名称和参数与 Proxy 捕捉器相同`。

用途：可以使用 `Reflect` 来将**操作转发**给**原始对象**

### 谈谈 web worker

### 惰性函数、柯里化函数

### a.b 的方式 a['b'] 的方式性能对比，原因

### for 循环为什么比 .foreach 性能高

### 数组长度为 100000，取首项和尾项的时间差距

## TS 篇

### interface 和 type 作用和区别（异同）

`Interface` 和 `Type` 主要起到**类型**的**限制**和**规范**的作用。

相同：

- Interface 能描述的类型，Type 基本也能实现。
- 两者描述的类型都能通过 `class implements` 实现。

不同：

- **Type** 可以描述一些**基础类型和数组（元组）类型、联合类型**。
- **Interface** 可以**定义多个同名**的**类型**（最终效果就是**合并**后的类型）。
- **Interface** 通过 **extends 扩展**类型（同名属性类型必须一致），**Type** 通过**交叉类型**实现。（同名则为 `never`）
- **Type** 支持 **in 动态属性**（`[k in B('a' | 'b')] 或者 [k in keyof B({ a: string; b: number })]`）。

---

### 泛型的了解（内置的泛型）

> TypeScript 泛型是**一种工具**。它能让开发者**不在定义时指定类型**，而在**使用时指定类型**。

常见有 `Readonly/Required/Partial/Pick/Omit/Record/ReturnType/InstanceType/Parameters/Exclude/Extract/...`

### 给函数添加泛型后，调用的时候不传类型默认是什么表现（类型）

形如: `function<T>(): T {}` 或者 `function<T>(param: T) {}` 或者 `function<T = any>() {}`等等。其实他们的**表现都不太一样**。

- 当泛型 **`T` 用作函数形参的类型**时，如果不传则**根据调用时的实参推倒类型**。
- 当泛型 **`T` 没有用作形参的类型**时，如果**不传则使用默认类型**，默认类型如果没指定则是 `unknown`。
- **不会抛异常**

---

## 算法篇

### 几种排序算法的手写

### 广度优先遍历、深度优先遍历

### 反转链表

### 平衡二叉树

### 树转列表、列表转树

## 框架篇

### 列表组件中的 key 的作用：

先说结论：**方便在 diff 过程中更准确、更快的找到旧的 vNode，从而提升 diff 速度**

- `key` 可以看作是 `vNode` 的唯一键，添加了 `key` 过后，可以通过 `map` 映射更快的找到旧的 `vNode`，而非遍历查找。

- 在 `vue/react` 中都是通过 `diff` 都是通过 `diff` 算法对比新旧的虚拟节点，从而更新节点，如果当前的 `key` 没有找到映射中对应的 `vNode`，则表示新增。

- 通常可以通过修改 `key` 这种方式在数据变化时强制更新界面组件的渲染，避免组件“就地复用”的副作用。

---

### 说说 diff 算法过程

先说概念：**diff 算法是用来对比新旧虚拟 DOM 的一种算法**，对比出哪些**虚拟节点**更改了。

> 当数据变化时，会触发 `setter`，并通过 `dep.notify` 通知所有 `订阅者 watcher`，然后订阅者就会调用 `patch` 方法给真实 DOM 打补丁，更新相应的视图。

`patch` 对比流程：

- 新旧虚拟 DOM 树进行同层对比，判断当前的虚拟节点是否为**同一种类型**的节点，如果是则继续通过 `patchVnode` 深层次对比，**若不是则直接整个节点(含子节点)替换为新虚拟节点**

> 至于是否为同一种类型节点对比，会对比**标签是否相同**、**key 是否相同**、**是否都是注释节点**、**是否都定义了 data、如果是 input 那么 type 是否一致**

- 在 `patchVnode` 对比进行深层比较时，会先判断**是否为同一个虚拟节点对象**，如果是则直接终止比对，若不是则先判断**是否为文本节点且文本不一致**，是则更新文本节点内容，不是则继续比对。比对**是否都含有子节点**，若（新旧虚拟节点）其中某个有子节点某个没有，则执行真实 DOM `即 el` 子节点的新增/删除，若都有子节点，则通过 `updateChildren` 比对两者的子节点并更新。

- 对于都有子节点的虚拟节点，则是**通过 `首尾指针法（头尾交叉对比，即新旧虚拟子节点列表都有头尾两个指针，4种相互对比方式：头头/头尾/尾头/尾尾）`移动指针对比找到可以复用的旧节点**，如果**找不到，则通过 key--> index 的映射关系查找**。

_（通过了解了 diff 原理，也就明白了 key 为什么不能是 index，因为如果新元素在首项插入，那么比对过程中列表的所有的节点都将被更新，因为相同 key 位置的节点内容都错位了）_

---

### vue/react diff 算法如何优化时间复杂度的？

复杂度从 `O(n^3) --> O(n)`，该题或者可以说如何时间复杂度计算出来的？

- 在没有 key 的时候，尝试将**老树的每个节点都去遍历新树的节点，直到找到新树对应节点，此时时间复杂度是 `O(n^2)`**，对比出不同后，再计算最短修改距离修改节点，故而总复杂度为 `O(n^3)`。

- 至于优化成了 `O(n)` ，则是因为以下三个策略来降低的：**父节点不同则放弃子节点的比较，直接替换（同层对比）、子节点变化不会关心变化的是什么而是直接替换渲染、key 策略通过映射查找旧节点**

---

### SSR 原理

`SSR（server side render 服务端渲染）`，参考：[https://github.com/yacan8/blog/issues/30](https://github.com/yacan8/blog/issues/30)

**Demo:** [https://github.com/yacan8/vue-ssr-demo](https://github.com/yacan8/vue-ssr-demo)

**SSR 优势**：

- 最早的服务端渲染是数据变化就会重新渲染整个页面，同时前后端代码并没有分离，维护相对困难。
- SPA 单页面应用虽然避免了这个缺点并在客户端请求资源渲染，但是缺并**不利于 SEO (Search Engine Optimization 搜素引擎优化)**。其实也就是不方便爬虫爬取，部分**低级爬虫**是**无法爬取通过 `js` 脚本渲染的页面**资源。。
- 资源获取都通过客户端请求，导致**首屏加载时间变长**
- 为了解决这些问题，SSR 服务端渲染再次出现了（不是最早的服务端渲染方案）。

**SSR 缺陷**:

- 开发成本提高（需要熟悉nodeJs，复杂的工程配置）
- 更高的服务器负载均衡（服务器增加了 html 渲染，提高了 CPU 占用）
- 需要 Nodejs 运行环境，不能直接部署到静态文件服务器

原理：

- **同构项目**，即路由、数据模型、模板组件在两端共享。（同构项目：让代码既能直接在客户端渲染，也能在服务端进行渲染）
  模板组件同构：
  - **分环境编译**：根据编译产出的环境不同，`将 webpack 打包配置分为两份`（`.client.config/.server.config`）、根据 **`cross-env` 分环境配置进行打包**
  - 入口处 **vue 实例初始化兼容**。分环境编写 vue 实例初始化代码（入口文件）
  - 服务器入口引入前面打包的 `webpack 构建结果（client-bundle 和 server-bundle）`
  - 利用 `vue-server-render` 插件提供的 `createBundleRender` **创建 `html 渲染器`。**
  - 服务端配置客户端构建的静态文件访问，并挂起全部路由请求，返回由上一步生成的`渲染器renderer` 生成的 html `renderer.renderToString(context, (err, html) => res.send(html))`

  路由同构：
  - 前面我们挂起了所有的路由请求，全部交给 vue 处理。所以需要在挂载实例(entry)的时候分别添加路由匹配
  - 修改客户端路由（同常规 spa，并挂载到实例）、修改 server-entry(export default (context) => return app)，通过 `context.url（server挂起路由的位置传入的当前 req.url`） 读取路由，并完成 `router.push(server 创建实例时会拿 router)`。

  数据模型同构:
  - 客户端 `vuex.store` 正常创建，同spa
  - 将该值**绑定到 context.state 上**，在服务端渲染时**会序列化到 window.__INITIAL_STATE__**
  - 修改client-entry，并将上面**序列化的值激活（同步）到 store**（`store.replaceState(window.__INITIAL_STATE__`)）

为什么没有传统的服务端渲染弊端（不同）？

- 本质上除了一些固定的配置项，实际的项目开发和客户端是一套代码（保留了 SPA 和 SSR 的各自的优点）。_尽管如此，还是需要权衡再使用_

---

### vue2/3 响应式原理（含数据劫持）

> **原理**简言之就是：**数据劫持**和**依赖追踪**。

> **响应式数据：当数据变化时，依赖它的函数重新执行**。

响应式实现：

vue2：

- 通过 **`Object.defineProperty` 遍历**数据data的**每一个属性**，把每一个属性**变成一个 `getter/setter` 函数**（读取的时候会运行 `getter`，设置的时候会运行 `setter`），变成**响应式数据**。
- 当**运行 render 函数**时，由于模板内使用了变量(上面提到的响应式数据)会**触发 getter 函数**执行，会**生成依赖**记录（也称**依赖收集 `dep`**）
- `dep` 记录会**生成相应的`订阅者 watcher`**（**发布订阅模式**，非观察者） 
- 当**数据被修改**时，会**触发 setter 函数**执行，此时通过 **`dep.notify` 发布通知**相关的**订阅者 watcher 执行**。（派发更新）
- `watcher` **依据**收集**来源是（`render 函数`）**，所以会**重新**触发 `render 函数`**执行**
- `render 函数`重新执行，生成`虚拟 DOM 树`，再通过 `diff 算法`对比`新旧虚拟 DOM 树`，更新`真实 DOM 树`

vue3：

> 大致流程和 vue2 一致。**区别**在于**响应式数据生成**方式：**前者通过 `Object.defineProperty`，后者通过 `Proxy` 劫持**。 

- 利用 `Proxy` 代理对象，通过 `get/set` 拦截对对象的访问，实现对对象属性的读取和设置。
- 其次：`vue Object.defineProperty` 无法监控对象属性的新增和删除，以至于新增属性会丢失响应式特性。（通过 `$set` 解决这一问题）

---

### 单向数据流

`通过限制父组件通过 props 单向给子组件传值，子组件不能直接修改这些 props，而是通过向父组件发送事件让父组件来修改传入的 props 数据实现单向数据流。`

通过单向数据流的设计，让数据的流动**变化更有迹可循**，`方便` **状态管理** 和 **调试错误排查**。

---

### vue 数据双向绑定原理

> 通过 `v-model` 语法糖实现。简化表单数据的绑定更新，视图和数据之间同步更新。

原理：

- `v-model` 是对 `:value/@input` 的封装实现
- 传入 `value`，当表单数据发生变更触发 `input 事件`，然后动态修改 `value`。 

---

### 虚拟 dom 真的比真实 dom 快吗？（为什么需要虚拟 DOM）

参考回答：[https://github.com/Advanced-Frontend/Daily-Interview-Question/issues/47](https://github.com/Advanced-Frontend/Daily-Interview-Question/issues/47)

> 八股文：由于操作真实DOM的代价是很昂贵的，为了避免在组件中直接操作大量的真实DOM导致页面卡顿，而引入了虚拟DOM，最后再为真实DOM打补丁从而提升性能。

对于两者谁更快的个人理解：

> 当组件结构以及操作足够简单时，直接操作真实DOM其实会更快。虚拟DOM无非是为开发者提供的保证性能下限的无奈选择，毕竟不管是否使用虚拟DOM，最终都需要操作真实DOM。

至于**为什么需要`虚拟DOM`**，我的理解：

- 框架设计。
  - 组件化开发不管是vue还是react，在**最终渲染界面**的时候，**都会执行 render 函数**（vue最终会将 template代码转为 h函数）。
  - 当组件里的**元素足够多**时，**数据的变更**需要**重新执行 render渲染**界面。
  - 运行 `render函数`就**需要做全量渲染**（因为**并不能**根据当前变化的**数据关联定位到具体DOM元素**，并不会产生对应关系。_至少在当前框架设计下很难实现_）
  - **全量渲染**会重新创建所有的DOM元素，这会**非常消耗性能**。
  - 因此在这样的设计下，选择了虚拟DOM（生成**虚拟DOM，也就是JS对象**），所谓的提升效率也是在此前提下提升的。（_这是个无奈的选择_）

- 跨平台支持。
  - **真实DOM只存在于浏览器**环境，当环境变化时，**无法做到跨平台**支持。
  - **虚拟DOM是一个普通的JS对象**，因此在跨平台时，只需要**将其与原生组件进行对应**，就可以轻松**实现跨平台**。

---

### react/vue 组件是如何实现组件更新（渲染）的？Fiber 架构（vue为什么不需要）？

react：

- 当组件属性、状态发生变化时，会触发**协调算法**来**比较`新旧`的虚拟DOM树**之间的差异，并**仅更新变化的部分**，从而实现高效的组件更新。
- 协调算法：
  - `Fiber 出现之前`，使用的是**递归调用算法**，由于递归**不能中断**，可能会导致大量的函数计算和堆栈溢出。当计算时间过长时，会**导致页面卡顿、无法响应用户操作**。
- Fiber 架构：
  - `Fiber 出现之后`，使用的是**循环调用**，将协调`过程`**分成**多个小的**任务单元**，这些任务单元**可暂停、恢复和终止**。这样就可以使浏览器**及时渲染并响应用户操作**。
  - 为了确保程序流畅以及更好的交互体验，需要在**任务执行**和**浏览器执行重要操作**之间**合理分配时间**。
  - 通过浏览器提供的 `requestIdleCallback api`，可以将任务放到每个渲染帧（60hz对应`16.6ms/帧`）的空闲时间来执行。
  - 当**帧空闲时间不够**时，**暂停**任务单元的执行（**由浏览器执行更高优任务**，如渲染页面和响应操作），**等待下一个帧空闲**时间恢复执行。
  - 直到任务单元**全部执行完毕**。（**合作式调度**）

为什么vue不需要使用：

- react 的协调算法中，更新是从根节点开始计算的。这可能会导致处理大型任务时出现性能问题。因此react才引入的 `Fiber`。
- vue是基于组件响应式设计的。（详细看前面响应式原理），只会计算发生变化的部分，不会重新计算整个组件树。可以提高大型应用的性能，所以不需要。

---

### vue 和 react 的区别

> React 和 Vue **同为现代化的 Web 前端开发框架**。相同之处**都是采用数据驱动视图**的思想，以**虚拟 DOM 为基础**，以**组件化**的方式组织应用，让开发者无需关心 DOM 细节，从更高的层次设计应用。不同之处在于，具体组件的**编写方式（template vs jsx）**，**数据响应模型**以及具体的**生态**。

开发体验：

- 从学习曲线上：
  - vue旨在降低前端开发门槛，提供了很多语法糖支持，对初学者更加友好，记忆成本相对高一些。
  - react更偏向于js编程，将html和css组合进js里，上手难度和学习成本相对vue来说略高。
- 从语法上：
  - vue提供了 `template/css/js` 的模板语法，分离模板、逻辑和样式，更贴近传统的前端，更易于维护。
  - jsx由于不受模板影响，更易于拆分，写法也更加灵活。

生态：

  - vue官方提供了开箱即用的vue-router/vuex支持。
  - react将选择权交给了开发者，当然现在社区也有很多成熟的方案。

核心区别：

- 数据模型：
  - vue是推模型。
    - 由于vue的响应式设计，当响应式数据变化时，会自动的通知订阅者执行更新。
  - react是拉模型。
    - react更倾向与函数式编程，鼓励使用不可变数据，当数据改变时，需要手动调用 setState 去更新视图。
  - 两种模型不是互斥的，在react中可以像mobx之类的库实现，vue也可以通过freeze来冻结对象。

---

### redux 和 vuex 的设计思想

### vue 中子组件和父组件同时存在，此时父子组件的整体生命周期顺序

> 渲染时：父beforeCreate->父created->父beforeMount->子beforeCreate->子created->子beforeMount->子mounted->父mounted

> 销毁时：父beforeDestroy->子beforeDestroy->子destroyed->父destroyed

---

### vuex 的 mutation 和 react 的 reducer 为什么不能做异步操作（为什么是纯函数）

先说**理念（作用）**：两者都是基于某些操作完成**对已有状态的修改或者更新**。因此抛开只想执行异步代码而不关心执行结果的情况（无意义）

如果是等待异步函数执行结束后修改状态，由于**异步函数的执行结果其实是不可控**的，那么**此次操作（修改状态）**的结果将变得**不可预测**，与**设计相悖**。

这也是为什么需要是**纯函数**，只有这样，相同的**操作结果才会可控（不产生副作用，状态可回溯）**。

---

### react-router 中的 Link 和 a 标签的区别

> `Link` 本质是基于 `a 标签`的实现。 

区别：

- `Link` **禁止**了 `a 标签`的**默认行为**，通过 **`history` 执行跳转**，**不会刷新**页面。
- `Link` 如果绑定了 `onClick` 会**先执行点击事件**

---

### react 事件机制原理

`React`**基于浏览器的事件**机制**自身实现**了一套事件机制，包括**事件注册、事件的合成、事件冒泡、事件派发**等（**磨平了浏览器差异，让表现统一**）

- `React` 上**注册的事件**最终会**绑定在 document**这个 `DOM` 上，而不是 `React` 组件对应的 `DOM`（减少内存开销）
- `React` 自身实现了一套**事件冒泡机制**（`stopPropagation` 无效），**通过队列**的形式，从触发的组件**向父组件回溯**
- 然后调用定义的 `callback`

---

### react setState 什么时候同步，什么时候异步？立即打印的输出结果？同情况下 vue 的表现？

> 由于 `vue 会对数据的变化做劫持`，所以不管如何操作数据，当被访问的时候都 **`是最新的，是同步（并将多个同步合并【变更同步，更新渲染异步】，只 render 一次）`**

react 的同步/异步时机：

- 同步：通过 **js原生api 包裹的 callback**都是同步执行（执行几次 `setState` 就 `render` 几次）
  - **promise.then(callback)**
  - **setTimeout(callback)**
  - **addEventListener(eventName, callback)**
  - **上面 callback** 内执行的 `setState`（此时 **react 无法控制**），就是**同步**的，每次都是**最新值**。

- 异步：react 控制的 `合成事件 onClick、hooks、生命周期` 内直接调用 `setState` 都是异步的。
  - **onClick function**
  - **useEffect function...**
  - **上面 function** 内执行的 `setState` 都是异步的，每次都是**旧值**，**不会立即变更**。
  - 解决办法：如果需要多次执行 `setState`，则通过回调更新，如果需要使用新值，则不通过 `state` 获取。

---

### react hooks 为什么不能循环、条件判断或者子函数中调用？

`如果在条件语句中使用 hooks，React 会抛出 error`

> **react 通过单向链表来严格保证 hooks 顺序**。条件语句中 `React会抛出 error`

- 组件在**首次渲染**的时候会构建一个基于 hooks 的**初始链表A**。（通过 next 指针可以找到下一个 hook）。

- 如果 hooks 不在顶层，或者因为某些原因而没有执行（被放入判断语句），那么在组件 **rerender 的时候**，按顺序**依次遍历之前构建**好的链表A，取出对应的数据信息**进行渲染**。

- 如果两次读到的链表在顺序上有差异，那么**渲染结果**将变得**不可控**。_（类似 useState 的 hook，通过顺序来索引到对应的状态值。）_

---

### react useEffect 的第二个参数传和不传的区别?（副作用函数的理解）

> 副作用函数：**和 UI 渲染无关**的业务逻辑**称之为副作用**。`useEffect` 是 react 函数式组件提出的**副作用函数**方案。

> `useEffect` 接收两个参数，第一个是回调函数（副作用函数），第二个参数是一个`数组（可以理解为依赖项：dependencies）`，依赖项变更会触发副作用函数执行。

- 如果**第二个参数不传**，表示**监听所有的属性**更新，在每次 render 时都会重新执行副作用函数（**等同 `componentDidUpdate 生命周期`**）。 
- 如果第二个参数是**非空数组**，则表示**监听传入的属性**变化，只要**其中一个发生变化**都会导致副作用函数的执行（**等同 `componentDidUpdate 生命周期`**）。
- 如果第二个参数如果是**空数组**，则表示只在组件完成挂载（插入DOM树）后立即执行，且只执行一次（**等同 `componentDidMount 生命周期`**）。

另外，**不管第二个参数穿不穿，是否非空，默认都会执行一次**。

副作用消除：

- 在每次 rerender 的时候需要消除上一次副作用函数执行所产生的副作用（如果需要），此时可以通过在副作用函数中 return 一个新函数实现。
- 这个 return 的新函数会在每次 rerender（组件卸载） 之前执行。（**当第二个参数为空数组时，此时的 return 新函数等同 `componentWillUnmount 生命周期`**）

---

### react useEffect 以及其 return 的函数调用顺序（含多组）

`下面的依赖统指 useEffect 的第二个参数项`

- 如果存在多组 `useEffect`（不管有无依赖，及是否为相同依赖），**首次渲染**时，都是**从上到下依次执行**其内的**副作用函数**。
- 当数据变更触发 **rerender 的时候**，先执行 useEffect **依赖了变更属性**(依赖含有/不传参)的 **return 函数**（消除副作用，也是**从上到下执行符合条件的**）
- **只有在组件被销毁前，`依赖项为[]` 的 useEffect 才符合副作用消除条件，才会执行 return 函数**
- **销毁时所有的 useEffect 副作用函数内 return 的函数都将从上至下被执行**

> `effect 函数`本身不支持异步（可以在内部定义一个 async 子函数）

> 特殊：受 **react18 新特性**影响，组件会经历 **组件挂载-->组件销毁-->组件重新挂载** 的过程，意味着 useEffect 也将多次执行。

---

### react useEffect 和 useLayoutEffect 区别

- useEffect 是在浏览器完成更新后**异步**调用 effect 函数，不会阻塞界面视图更新。
- useLayoutEffect 是在浏览器完成**界面更新前同步**调用 effect 函数，可以阻塞界面更新，从而读取布局信息。

因此，useLayoutEffect 的执行比 useEffect 更早，更适合执行 `DOM 操作`，避免界面闪烁。

> 如果需要**读取布局信息**并在**浏览器完成渲染之前**执行某些操作，则需要**使用 useLayoutEffect**。否则使用 useEffect。

---

### react useLayoutEffect 和 componentDidMount 区别

- 两者**都是组件被挂载到 `DOM` 之后执行（且只在挂载时执行一次【`useLayoutEffect` 依赖为空数组】）**的，都能在函数体内执行一些操作如操作 DOM/网络请求等。
- 不同的是 **useLayoutEffect 是同步**操作而 **componentDidMount 是异步**执行的，**useLayoutEffect 时机更早**。

---

### react useEffect（hooks） 实现原理

> **`Hooks` 主要是利用`闭包`来保存状态，使用`链表`保存一系列 `Hooks`，将链表中的`第一个 Hook` 与 `Fiber` 关联。**

原理：

- 基于 Fiber 架构，每个组件都是一个 Fiber 节点，这个节点保存了组件的状态属性和子节点信息。
- 会在 Fiber 树的首次渲染和组件更新时**创建 effect 对象添加到 effect 链表**中。
- 组件 rerender 时，会先执行上一次的清除函数(如果有)，再执行本次的 effect 函数。
- 为了避免阻塞渲染，react 会将 effect 函数添加到异步任务队列中，等待浏览器空闲时执行。

---

### react useState 和 useReducer 区别

> 都能进行状态管理，useReducer（适合逻辑比较复杂的state） 是 useState（适合定义一些简单的状态） 的升级hook实现。然后就是一些使用上的区别。

---

### react HOC / Render Props / Hooks 作用和区别

**都可以提高代码的复用性**

HOC:高阶组件，**接收一个组件作为参数，返回一个新的组件**。

> 作用：**复用逻辑**，**抽离组件公共部分**，**渲染劫持**，**操作 props**。

> 缺点：**嵌套地狱**，**组件复用性差**，**组件粒度太小**，**组件可读性差**。

Render Props: 接收一个 Render 函数作为 prop，通过组件调用时传入本组件state，根据render函数的不同动态完成渲染。（`{ props.render(state) }`）

> 作用：组件内容渲染更加灵活，传入什么渲染什么。

Hooks：是一个函数，可以将一些可复用的逻辑抽离封装的一个个的hook，可读性更高，使用也更灵活。

---

### vue/react 组件之间的通信方式

vue 组件之间通信：

- 通过 `prop/emit <==> v-model <==> .sync` 通信。（向子组件传递 prop，子组件通过 emit 事件来告知父组件修改传入的 prop 值）
- 通过 `inject/provider` 通信。（适用多层级嵌套的子孙组件）
- 通过 `$attrs/$listeners` 通信。（同适用多层嵌套的子孙组件） 
- 通过 `$refs` 获取组件的属性和方法。（直接调用）
- 通过 `$parent/$children` 获取组件，然后调用组件的属性和方法。（同 $refs 直接调用）
- 通过 `eventBus：$on/$emit` 事件总线通信。（任意组件之间通信）
- 通过 `vuex`状态管理器进行通信。（任意组件之间通信）
- 通过 `localStorage/sessionStorage` 通信。

react 组件之间通信：

- 通过 `prop` 通信。（通过调用 props 传入的回调方法由父组件更新 prop）
- 通过 `ref/useImperativeHandle` 通信。（父组件获取子组件的方法和属性）
- 通过 `useContext：provider.value/dispatch` 通信。（层级较深的组件之间通信）
- 状态管理机。（包括不限于 dva）
- 通过 `localStorage/sessionStorage` 通信。

---

### vue3 新特性

- setup：组合式 API 入口 `setup(){} <==> script setup`
- ref/reactive: 通常前者创建基础变量（也可创建引用变量），后者创建引用变量（如果是数组则会转为对象）
- computed/watch/watchEffect：前者是计算属性后者是监听处理，effect 则既是监听又是处理（无需指明具体监听对象，根据使用推导）
- 生命周期：vue2 的一些等价生命周期替换
- getCurrentInstance <==> this
- other 太多了看官网吧...

---

### react18 新特性

- 引入了 `rootApi (createRoot...)`，支持**并发模式的渲染**
- 自动批处理：**任何情况（含异步回调中）**都将多个状态变更一起**批处理**，减少不必要的渲染，提高了渲染效率。（通过 `flushSync 回调`执行的不会批处理）
- **空组件**返回值**不再强制**要求`null`（18中提示的错误，仅类型检查提示，不会出现运行时异常）
- 日志优化：严格模式下，组件会执行两次渲染。（17 只log了一次，18将第二次log置灰了）
- ...

---

### react 性能优化方案

跳过不必要的组件更新：

- `PureComponent`、`React.memo` 对 `props` 进行浅比较  
- `shouldComponentUpdate` 子组件使用的属性发生改变时才返回 `true`
- `useMemo、useCallback` 实现稳定的 `Props` 值（缓存）

---

### spa（单页应用程序） 中的路由实现

前端路由可以实现无感刷新，分为 **Hash 路由** 和 **History 路由**

> **hash 实现**：**监听 `hashchange 事件`**来监听`页面 hash` 的变化，**渲染不同的页面**

> **history 实现**：浏览器**原生提供的操作 History** 的能力来实现的路由功能。`监听 popstate`，解析出路由后渲染不同的页面。需要服务端完成相应的配置（指向同一个html）

## NodeJS 篇

### npm 安装模块的机制（为什么可以自动安装）

### token 加密实现

### sql 的基础增删改查

### 文件读写

### 流和管道理解

### 中间件的实现

### NestJS `守卫（guard）`和 `过滤器（filter）` 实现

### SSO 单点登录（统一用户中心）实现原理

拥有**相同**的顶级域名：

- 登录后将 `cookie（sessionId或token）` **设置到顶级域名**（`domain父域，path根`）下，被所有的**子域共享**。
- 用户**访问**该顶级域名下的**其他子域**时，会**自动携带这个 cookie**

拥有**不同**的域名：

- 不同域的情况，cookie 是不共享的，此时我们就需要一个都能访问的**认证中心**。
- **访问子系统**A时，先跳转到认证中心，**在认证中心完成登录**。
- 认证中心**记录用户的登录状态**，并将 `cookie` 设置到认证中心（子系统无法访问）
- 访问子系统B时，由于此时没有 `token`，说明没有在子系统B登录过，则跳转到认证中心。（如果之前登录过子系统A，那么认证中心会存有`登录状态的 cookie`，此时会被携带）
- 认证中心根据携带过滤的 `cookie` 判断用户有没有在其他子系统登录
- 如果判断结果没有登录过则跳转登录，如果登录过则重定向并在url上**携带 `token` 回到目标系统**。
- 目标系统拿到该 token，向认证中心验证**合法性（防止伪造）**，合法则完成登录过程。
- 完成子系统B登录后，记录相关的 `cookie`，后续请求自动携带。

---

### RESTful 接口规范理解

- 标准的 http 请求方法（GET/POST/DELETE/PUT..）和响应状态码
- 响应足够详细
- 所有的资源都有唯一标识符(url)，根据请求资源添加合适的缓存机制，提升性能

## 项目篇

### 如何处理输入框中中文输入的防抖

### 实现模糊搜索结果中的关键词高亮显示

### 如何判断输入框中输入的是正确的网址

### vm模块和eval对比

- eval，可以执行一段字符串形式的 javascript 代码，并在当前环境下执行。
- eval 严重存在安全性问题，它可以访问到当前环境的变量和对象，如果执行恶意的代码，会造成不可预料的影响。

- vm 模块可以模拟一个沙箱环境，用于执行 javascript 代码，这个环境是隔离的。（不会对主程序造成影响）更加安全。
- vm 漏洞：通过 this.constructor 是可以向上访问拿到 process 的，所以为了解决这个问题可以传入一个修改了this的上下文。
- vm2解决了这个问题，相对更加安全（除非物理隔离，否则不存在绝对）

---

### 大文件的断点续传

### 谈谈项目优化方案

### 如何减少白屏时间

基于代码层级的优化：

- 组件异步加载、公共组件抽离减少代码量，避免单文件体积过大
- 如果首屏存在图片或者列表数据，则使用懒加载（默认只取缩略图、少量数据渲染）

基于bundle的优化：

- 第三方资源使用cdn引入加速，不加入打包过程
- bundle分片，根据不同模块碎片化打包，避免单个资源过大的问题
- 打包结果分析，根据使用情况，异步加载相关资源（实际使用的页面才异步加载相关自用，避免入口bundle过大）

基于网络的优化：

- DNS 预解析和优化（link元素添加`ref="dns-prefetch"`）
- 服务端添加gzip对资源进行压缩
- 使用雪碧图，减少http请求数。
- 服务端配置静态资源http缓存策略（强缓存、协商缓存），避免每次都重新请求一些固定的资源
- 增加服务器带宽，至少在服务端方面不拉跨。

基于体验的优化：
- 添加相关加载动画、添加入口前置页面（例如app首屏封面），让用户无感知
- 添加骨架屏，缩略图...
- 资源预加载

### 渲染大量数据（100000条），如何优化

- 虚拟列表，又称**可视区域渲染**（`interSectionObserver`）
- **懒加载，延迟渲染**（尽管已经获取到了100000条数据，可以在客户端模拟假的数据加载）
- **任务分片**，每次执行一部分任务渲染（异步回调，or渲染**帧空闲时分批次处理**任务`requestIdleCallback`）

## 工程化篇

### 微前端方案

### lerna 和 yarn workspace 使用，以及两者差别

### lerna 发布过程中的异常处理

### Babel 的原理

> Babel 是 JavaScript 编译器：他能让开发者在开发过程中，直接使用各类方言（如 TS、Flow、JSX）或新的语法特性，而不需要考虑运行环境，因为 Babel 可以做到按需转换为低版本支持的代码；Babel 内部原理是将 JS 代码转换为 AST，对 AST 应用各种插件进行处理，最终输出编译后的 JS 代码。

- 解析阶段：Babel 默认使用 @babel/parser 将代码转换为 AST。解析一般分为两个阶段：词法分析和语法分析。
- 词法分析：对输入的字符序列做标记化(tokenization)操作。
- 语法分析：处理标记与标记之间的关系，最终形成一颗完整的 AST 结构。
- 转换阶段：Babel 使用 @babel/traverse 提供的方法对 AST 进行深度优先遍历，调用插件对关注节点的处理函数，按需对 AST 节点进行增删改操作。
- 生成阶段：Babel 默认使用 @babel/generator 将上一阶段处理后的 AST 转换为代码字符串。

---

### webpack 的 plugins 和 loaders 区别

> webpack 本身只能处理 JavaScript 和 JSON 文件，而 loader 为 webpack 添加了处理其他类型文件的能力。

区别：

- loader，它是一个转换器，将A文件进行编译成B文件，比如：将A.less转换为A.css，单纯的文件转换过程。
- plugin是一个扩展器，它丰富了webpack本身，针对是loader结束后，webpack打包的整个过程，它并不直接操作文件，而是基于事件机制工作，会监听webpack打包过程中的某些节点，执行广泛的任务

> 简言之：loader 一般是将某个语法统一处理为统一的语法，plugin一般是在打包前或打包后对结果进行再次操作

---

### webpack 打包原理（流程）

> webpack 是一种模块打包工具，可以将各类型的资源，例如图片、CSS、JS 等，转译组合为 JS 格式的 bundle 文件。

初始化阶段:

- 初始化参数：从配置文件、配置对象和 Shell 参数中读取并与默认参数进行合并，组合成最终使用的参数。
- 创建编译对象：用上一步得到的参数创建 Compiler 对象。
- 初始化编译环境：包括注入内置插件、注册各种模块工厂、初始化 RuleSet 集合、加载配置的插件等。

构建阶段:

- 开始编译：执行 Compiler 对象的 run 方法，创建 Compilation 对象。
- 确认编译入口：进入 entryOption 阶段，读取配置的 Entries，递归遍历所有的入口文件，调用 Compilation.addEntry 将入口文件转换为 Dependency 对象。
- 编译模块（make）： 调用 normalModule 中的 build 开启构建，从 entry 文件开始，调用 loader 对模块进行转译处理，然后调用 JS 解释器（acorn）将内容转化为 AST 对象，然后递归分析依赖，依次处理全部文件。
- 完成模块编译：在上一步处理好所有模块后，得到模块编译产物和依赖关系图。

生成阶段:

- 输出资源（seal）：根据入口和模块之间的依赖关系，组装成多个包含多个模块的 Chunk，再把每个 Chunk 转换成一个 Asset 加入到输出列表，这步是可以修改输出内容的最后机会。
- 写入文件系统（emitAssets）：确定好输出内容后，根据配置的 output 将内容写入文件系统。

> 简言之就是读取配置文件，通过入口文件开始分析，利用babel对模块进行编译，并构建AST语法树。递归分析依赖，生成依赖关系图，。根据关系图将编译结果组装厂多个模块的chunk...

---

### webpack 打包优化

### webpack 热更新原理

### webpack 和 rollup 对比

### 谈谈代码测试实施

## 网络篇

### http 和 https 的区别

- **安全性**：`http` 是明文传输，有被**截获篡改**的风险；`https` 是基于 `ssl`协议的**加密传输**，**更加安全可靠**。
- **证书**：`https` 需要 `CA` （证书颁发机构）颁发的证书进行加密和解密操作。因此在使用 https 时需要配置证书，http 则不需要。
- **端口**：`http` 默认端口是 `80`，`https` 默认端口是 **`443`**。

---

### https 的加密算法、秘钥交换原理

### https 中间人攻击

### http 长连接 和 tcp 长连接（区别）

**HTTP 长连接**：

- HTTP 1.1 默认开启，1.0 默认关闭
- 在请求 header 头上添加 `Connection: Keep-Alive`，服务端收到请求后会在响应头中添加 `Connection: Keep-Alive`，保证连接不中断。
- 如果需要关闭 `keep-alive` 则在请求头里添加 `Connection: close`（一般会在服务上配置长连接的超时时间（可以理解为使用了防抖）：`keepalive_timeout`，超过了这么长时间没有新请求将关闭）

**TCP 长连接**：

`TCP 的 Keepalive` 就是**一种保活机制**： 

- 客户端和服务端建立连接后，如果**长时间没有数据交互**，会**触发保活机制**。
- 向对端发送保活的探测报文看**是否响应正常**（正常的话时间就重置，和前面提到的防抖处理差不多）。
- 如果**对端主机崩溃**（或者其他原因**导致报文不可达**），会**多次尝试**（超过探测阈值时**判断 TCP 连接死亡**）。

> 保活机制**默认是关闭**的，需要通过设置相应的配置参数才能使用。(通过 `socket` 接口设置 `SO_KEEPALIVE`)


### http1.0/1.1 和 http2.0 区别

- `1.0`

  - 不支持断点续传
  - 默认不保持长连接，每次请求都需要重新建立连接（如果需要，将其设为 close 外的其他值）
  - 只支持 `Get/Post` 请求方法
  - 仅有 **`If-Modified-Since（只能用于 Get/Post）、Expires`控制缓存**。`96 年`引入，是最基础的协议。

- `1.1` 在 `1.0` 的基础上：

  - 支持 **`keep-alive` 长连接，每次连接支持多次请求发送**
  - 支持**断点续传**(请求头 `Range` 实现)
  - 引入了其他**标识（`E-tag、If-Unmodified-Since、If-Match、If-None-Match`）来控制缓存**是否失效
  - 此外**支持更多的 `RESTful 风格` 的请求方法**，如 `PUT/DELETE等`。`99 年`提出。

- `2.0` 在 `1.1` 基础上：
  - 支持`header` **头部压缩**【`HPACK` 算法】 （由于`1.1`以后头部通常会放很多的标识符导致头部偏重，存在高占用问题）
  - 采用**二进制编码**（摒弃了之前的纯文本形式），将请求和**响应数据分割**为一个或多个的**体积小的帧**，提升了解析效率。
  - **多路复用**：允许在单个 TCP 连接上并行地处理多个请求和响应。【引入帧和流的概念】

> 1.x 不能多路复用，是因为响应是基于文本分割，一次只能处理一个请求或响应

---

### http 的无状态

`无状态协议(Stateless Protocol)` 就是指**浏览器对于事务的处理没有记忆能力**

结论：严格意义上来说，在 `http1.1/1.0` 是无状态的。`http2.0` 由于存在 `GOAWAY` 消息和握手，是可以算作有状态的（社区争议）。

原因：

- 在 `http1.1` 之前，每次请求都需要建立 `TCP` 连接（三次握手），而且每次请求都包含了所需要的完整数据，不涉及状态变更。即使是 `http1.1` 支持了 `keep-alive` 长连接，允许一次连接发送多个请求，它也并没有改变这个结果（**无记忆：不会在服务端保存任何浏览器的信息**）。

> [`https://github.com/lgwebdream/FE-Interview/issues/1213`](https://github.com/lgwebdream/FE-Interview/issues/1213)

解决方案：

- 正因为 `http` 的无状态，**`cookie` 应运而生**。

> `client` 发送请求后，由 `server` 设置响应头（`set-cookie`），`client` 会保留 `cookie`，之后的请求都会附带 `cookie` 头部信息。
>
> 但是 `cookie` 可存储内容有限，直接暴露在浏览器也存在一定的**泄漏风险**，所以就需要**使用 `session` 在服务器存储**相关用户信息。

- 为了将 `session` 中的内容与访问的 `client` 挂钩，通常会通过 `sessionId` （中存在 `cookie`）进行标识。

> 存到 `session`，用户多了以后会增大开销，为了提升效率，需要做分布式和负载均衡（后端完成）

- **`sessionId` 中存有 `cookie`**，仍**有被伪造的风险**（`CSRF`），为了保护这些信息，通常会**使用 `token` 来鉴权**，用于验证 `client` 身份。

---

### http 状态码

<div>

> 1：请求收到，继续处理

> 2：操作成功收到，分析、接受

> 3：完成此请求必须进一步处理

> 4：请求包含一个错误语法或不能完成

> 5：服务器执行一个完全有效请求失败

> 100——客户必须继续发出请求

> **101——客户要求服务器根据请求转换 HTTP 协议版本，服务器同意了**

> **200——交易成功**

> 201——请求被成功处理，并已完成资源创建（通常用于 POST）

> 202——收到请求、但还未进行处理

> 203——返回信息不确定或不完整

> 204——请求收到，但返回信息为空

> 205——服务器完成了请求，用户代理必须复位当前已经浏览过的文件，**通知客户端刷新页面更新资源**

> 206——服务器已经完成了部分用户的 GET 请求

> 300——请求有多种可能的响应。

> 301——请求的资源被**永久**重定向，重定向的地址为 HTTP 响应头（Location）指定的 URL

> 302——请求的资源被**暂时**重定向，重定向的地址为 HTTP 响应头（Location）指定的 URL

> 303——重定向，通常为 PUT 或 POST 操作的返回结果。

> **304——请求资源无变化，可以通过缓存获取。客户端已经执行了 GET，但文件未变化**

> 305——请求的资源必须从服务器指定的地址得到

> ~~**306——前一版本 HTTP 中使用的代码，现行版本中不再使用**~~

> 307——申明请求的资源临时性删除

> **400——错误请求，如语法错误**

> 401——请求授权失败

> 402——保留有效 ChargeTo 头响应。**保留的状态码，实际没有浏览器支持**

> **403——请求不允许。**一般用于权限不够获取该资源的时候使用

> **404——找不到相关资源。没有发现文件、查询或 URl**

> **405——用户当前的请求 http 方法不允许**

> 406——根据用户发送的 Accept 拖，请求资源不可访问

> **407**——类似 401，用户必须首先在**代理服务器上得到授权**

> 408——客户端没有在用户指定的饿时间内完成请求

> 409——对当前资源状态，请求不能完成

> 410——服务器上不再有此资源且无进一步的参考地址

> 411——服务器拒绝用户定义的 Content-Length 属性请求

> 412——一个或多个请求头字段在当前请求中错误

> 413——请求的资源大于服务器允许的大小

> 414——请求的资源 URL 长于服务器允许的长度

> 415——请求资源不支持请求项目格式

> 416——请求中包含 Range 请求头字段，在当前请求资源范围内没有 range 指示值，请求也不包含 If-Range 请求头字段

> 417——服务器不满足请求 Expect 头字段指定的期望值，如果是代理服务器，可能是下一级服务器不能满足请求

> **500——服务器产生内部错误**

> 501——服务器不支持请求的方法

> 502——网关或代理的服务器，从上游接收的响应是无效的

> **503——服务器过载或暂停维修，暂时不可用**

> **504——响应超时**。关口过载，服务器使用另一个关口或服务来响应用户，等待时间设定值较长

> **505——服务器不支持或拒绝支请求头中指定的 HTTP 版本**

</div>

---

### TCP 和 UDP 的区别

**都是位于计算机网络模型中的传输层协议。**

区别：

- **UDP** 无需握手建立连接，从而低延迟速度快、支持大数据包发送，允许 DNS 查找、是无连接协议。
- **TCP** 通过**握手挥手**确保连接的建立和关闭，所以速度会比较慢、支持错误重传，更加可靠、是面向连接的协议。

### TCP/IP 三次握手和四次挥手

概念：**`TCP` 是可靠的面向连接、字节流、传输层的协议/服务**。在客户端和服务器两端的内存中分别记录一些信息，比如 `IP`、端口等。通过三次握手过程在客户端和服务端建立连接，通过四次挥手来关闭连接（双工关闭，需要两边都确认以及发送关闭请求）。

- **三次握手**(开始)

  - 客户端向服务器发送 `SYN` 报文，并指明客户端的初始序列号`(INS c)`
  - 服务器收到客户端的 `SYN` 报文，向客户端发送自己的 `SYN` 报文，并指定确认的 `ACK(INS c+1)`，同时指明自身的初始序列号 `(INS d)` (得出结论：客户端发送正常，服务器接收正常)。
  - 客户端收到服务器的 `SYN` 报文，向服务器发送 `ACK(INS d+1)` 确认码(得出结论：服务器发送正常，客户端接收正常)。

- **四次挥手**(结束)

  - 当主机 `A` 完成数据传输后，提出停止 `TCP` 连接的请求。
  - 主机 `B` 收到作出响应，确认 `TCP` 连接将关闭。
  - 由 `B` 端再提出反方向的关闭请求。
  - 主机 `A` 对主机 `B` 的请求进行确认，**双方向的关闭**结束。

> **主机会在挥手结束，两个单位时间后才断开连接，防止服务器会突然发送其他请求**。避免最后的 `ACK` 丢失而导致另一方不断重传 `FIN`。

---

### Get 和 Post 区别

两者都是前端 `http` 请求中比较常用的请求方法。

- 类型： `Get`通常用作资源的获取，Post 一般用于资源提交，所以前者传输速度相对更快。

- 安全性：`Get` 是通过 `query` 的方式传输参数，直接暴露在请求链接中，容易被窃取；`Post` 通常用请求体 `Body` 传输参数，更加安全。

- 长度限制：`Get` 请求由于参数都放到了 `URL` 中，所以需要严格限制`URL` 的长度；`Post` 请求由于参数通常都在请求体中，说无限制也不为过。

- 缓存：`Get` 请求内容会被浏览器主动 `cache`，同时参数会保留在浏览器历史记录； `Post` 默认不会。此外 `GET` 在浏览器回退时是无害的，而 `POST` 会再次提交请求。

- 请求编码：`GET` 请求只能进行 `url` 编码，而 `POST` 支持多种编码方式。

- 参数类型：`GET` 只接受 `ASCII` 字符，而 `POST` 没有限制。

- 时机：`GET` 请求浏览器会将 `header、data` 一起发送出去，服务器响应 `200`；`Post` 请求浏览器先发送 `header`，服务器响应 `100 continue`，浏览器再发送 `data`，服务器响应 `200 ok`（**火狐浏览器除外**）。**`Post` 发两次数据包的原因：第一次检测服务器是否能够正常应答**

> 像在浏览器地址栏中输入链接访问、标签中的链接，其实都是一次 `Get` 请求

---

### ajax(xhr) 和 fetch 区别

`ajax` 是概念，`axios` 是封装，`xhr 和 fetch（es6，基于 promise 实现）` 是实现。

ajax 原理（狭义理解 xhr封装过程）:

- 创建 XMLHttpRequest 对象
- 调用 xhr 实例对象的 open 方法与服务端建立连接。
- 通过调用 xhr 实例对象的 send 方法发送请求数据。
- 通过监听 xhr 实例对象的 onreadystatechange 事件（readState=4表示完成）来获取服务端返回的数据。

fetch 原理：

- `fetch` ：浏览器提供的原生请求 API。（**返回一个 promise**，当**接收到 http 响应头**的时候，**执行 resolve**，在 then 的回调里**所有的响应信息**都可以通过参数拿到）
- `fetch` 即使遇到**错误的请求码**，也会**进入 `resolve then` 回调**，仅**网络错误**或**请求取消**才`进入 reject`

主要区别：

- `fetch` 本身不支持请求取消，可以通过 `AbortControl` 生成一个 `control 控制器`，在请求时传入签名，取消时执行 `control.abort()`。而前者可以调用实例方法 `xhr.abort()` 取消。
- `fetch` 默认不带 `cookie` 发送请求，需要设置 `credentials` 属性为 `include`，`xhr` 默认会携带。
- `fetch` 无法监控文件上传进度（根据 resolve 时机不难得出这个结论），而 `xhr` 可以。
- `fetch` 支持重定向，而 `xhr` 不支持（局部刷新，返回的是重定向的登录页html纯文本信息）
- ...

---

### XSS 攻击和 XSRF 攻击（前端安全）

> XSS: 又称 `CSS(Cross-site scripting) 跨站脚本攻击`，常见的有 `存储型 XSS`、`反射型 XSS`、`DOM 注入型 XSS`

XSS 注入方式：

- 存储型 XSS：**将恶意代码存储在服务器端**，服务器端将恶意代码返回给浏览器，浏览器解析执行。常见评论、发帖、私信等
- 反射型 XSS：**将恶意代码存储在 URL 参数中**，服务器端将恶意代码返回给浏览器，浏览器解析执行。常见搜索、跳转
- DOM 注入型 XSS：**将恶意代码存储在 DOM 对象中**，浏览器解析执行。

> 总结就是**攻击者提交恶意代码、浏览器执行恶意代码**

XSS 预防：

- 输入过程中过滤（通过正则/转义）恶劣代码，然后提交给后端。
- 后端存储时过滤。 
- 尽量避免 `v-html/dangerouslySetInnerHTML...`使用。

XSRF：又称 `CSRF(Cross-site request forgery) 跨站请求伪造`，常见的有 `GET`、`POST` 请求。

XSRF 流程：

- 受害者登录A，并保留了登录凭证（cookie）
- 攻击者引诱用户访问了B 如图片..（GET）
- B向A发起请求，A以为是受害者发起的，从而执行了攻击者指定的操作

XSRF 预防：

- 阻止不明外域的访问：**同源检测**(请求头`Referer`判断请求域)、**Cookie添加`sameSite`限制只允许当前域请求携带**
- 服务端生成只有**本站点能够访问的 token**，客户端请求时携带，由服务端验证有效性。
- 一些敏感操作，**添加验证码、人机验证**

---

### cookie 和 token 都存放在 header 中，为什么 token 不会被劫持？

- **防止 CSRF**。主要是**因为 `cookie`** 在每次请求时都会**被浏览器自动携带**，**容易被 CSRF 攻击**，而浏览器不会自动携带 `token`。

> `CSRF`: 用户网站登陆-攻击者网站-攻击者请求用户网站的方式

### 短轮询、长轮询、SSE 和 websocket 区别

短轮询和长轮询的目的都是用于实现客户端和服务器端的一个即时通讯。

短轮询：浏览器每隔一段时间向浏览器发送 http 请求，服务器端在收到请求后响应。【需要不断的建立连接，会增大服务器压力】

长轮询：首先由客户端向服务器发起请求，当服务器收到客户端发来的请求后，如果有更新才返回，否则会持续挂起（一直等待更新或者超时才会返回）【连接挂起会导致资源的浪费】

`SSE(server send event)`: 服务器使用流信息向服务器推送信息。单工通信，只能服务端向客户端推送（基于流实现，使用**流信息**向浏览器**推送信息**，场景：新闻推送）【IE低版本不兼容】

- 客户端通过 `new EventSource(url)` 建立 `SSE`
- 服务器端通过 `res.writeHead(200, { 'Content-Type': 'text/event-stream' })` 设置响应头
- 服务器端通过 `res.write('data: ' + data + '\n\n')` 向客户端发送数据
- 客户端通过 `eventSource.onmessage = function(e) { console.log(e.data) }` 监听 `SSE` 事件

`websocket`: 浏览器和服务器建立一个**持久化**的连接，两者可以**双向通信**。【**基于HTML5的新协议**，允许**相互发送消息**，场景：聊天】

---

## 浏览器篇

### 渲染原理和性能提升

> `当浏览器进程获取到 HTML 的第一个字节开始，会通知渲染进程开始解析 HTML，将 HTML 转换成 DOM 树，并进入渲染流程。`

原理：

- **浏览器通过请求得到一个 `HTML` 文本**

- **渲染进程解析 `HTML` 文本，将元素转换为 `DOM` 节点，从而构建 `DOM 树`**

> 过程：转换（原始字节根据编码转换为字符）、分词（根据 HTML 规范将字符串转为元素标记）、语法分析（将元素转为对象）、DOM 构造（将元素对象转为具有层级结构的 DOM 树）

- 如果遇到内联样式或者样式脚本，**`CSS 解析器` 解析样式规则并构建 `CSSOM 树`**；若遇到 `script` 脚本，则网络线程下载脚本并解析执行。

- **`DOM 树`和 `CSSOM 树`构建完成后，渲染进程将两者合并成`渲染树 Render Tree`**

- `渲染进程`开始`对渲染树`进行`布局`，生成`布局树 Layout Tree`（**计算所有元素位置和大小**）

- `渲染进程`对布局树进行**绘制**，生成绘制记录

- `渲染进程`的对布局树进行分层，分别栅格化每一层，并得到合成帧

- 渲染进程将**合成帧**信息发送给 `GPU 进程` **(渲染)显示**到页面中

性能提升：

- 保证渲染流程不被阻塞（办法：`script 添加 defer(等到 DOM 解析完成后执行，然后触发 DOMContentLoaded)` 属性，或者将脚本代码放至 `Body 结束标签`之前，在最后才执行 `JS`）。**`async 和 defer 类似`**，可以看作是**完全独立的脚本**（**不会等待**别的 `JS` 加载执行 or `Dom` 解析）

- **避免**不必要的绘制计算和**重排**(位置大小字体等改变)**重绘**(含前者，还包括颜色背景)

> **优化影响渲染速度**的资源：css 和 js 尽量不内联，css 放头 js（添加 defer 和 async） 放尾部

- **`GPU` 硬件加速**

---

### 浏览器的重排重绘

### 浏览器跨域的原因以及解决方式

跨域产生的原因：**浏览器的同源策略**

- 浏览器安全策略，保障非同源资源之间数据访问的安全性，默认不允许非同源的资源直接访问。

- 同源：**协议、域名、端口**完全一致，只要三个中有任何一个不一致，则非同源。

解决方案：

- **`CORS` 跨域**。全称 `cross-origin resource sharing`，由头端配置默认允许访问的域响应头（`CORS` 注解）。eg.'Access-Control-Allow-Origin:http://localhost:5500'(安全信较低)

- **`JSONP` 跨域**。由于是通过 **`scr`** 的方式（**开放性原则**）传入地址，所以**只能发起 GET 请求**，同时需要后端协作。

> 前端定义一个全局函数，后端返回函数的调用的字符串`fn()`，前端拿到这个字符串以后就会当成 `js` 代码区执行。

- **proxy 代理跨域**。服务器之间不存在跨域问题，所以可以从自己的服务器去访问别人的服务器，从而实现跨域。（**依赖同源的服务端对请求做一个转发处理，使之成为同源请求**）

### LocalStorage 和 SessionStorage 跨域

> `LocalStorage` 和 `SessionStorage` 同样受到同源策略的限制。而跨域读写的方式可以使用 `postMessage`

### 浏览器输入 url 到页面展示过程

- 浏览器输入地址比如 `http://www.xx.com`，根据域名和端口号通过 `DNS` 解析成 `IP` 地址。
- 根据 `IP` 地址以及端口号找到对应的服务器`（http 默认端口是 80，https 默认端口 443）`
- 通过 `TCP` 协议三次握手创建连接。（四次挥手关闭连接）
- 服务器接收到来自前端的请求，分配到对应路由处理，决定返回的资源（一般后端找不到对应服务时，会重定向返回 `index.html`）
- 客户端收到资源，完成后续处理（如果是页面，则解析渲染，然后根据页面标签（`link、script`等向服务器发请求...））

---

### 浏览器(`HTTP`)缓存

- **概念**：浏览器缓存是在本地磁盘存储的网络请求的资源副本，以便下一次访问时重复使用。

- **好处**：避免重复的资源传输，节省通信流量和通信时间，降低服务器压力，提升网页加载速度。

- **策略**：**强缓存**（不询问，直接使用本地缓存）、**协商缓存**（询问服务器缓存是否还有效，是否能继续使用）

`尽管协商缓存同样是一次请求询问的过程，但是如果缓存有效，就只会返回 304 状态码，因此传输会非常小。`

> 流程：
>
> 浏览器在发起请求之前，先判断是否存在该资源缓存（**该缓存不存在就直接向服务端发请求**）
>
> 若存在缓存资源先根据**头信息中的 `expires(过期时间)/cache-control(优先级更高，记录了缓存方式和过期时间)`**，**判断资源是否过期（是否要发请求）** `cache-control: public/private(仅客户端)/no-cache(协商，默认)/no-store(两种方式都不)/max-age(过期时间，秒)`
>
> 若符合上面说的条件（**缓存有效**），则直接使用缓存内容**强缓存**。若**不符合（失效）**则需要**询问服务器**缓存能否继续使用（**协商缓存**）。
>
> 浏览器将**缓存响应中的 `ETag(服务端生成的随机数|哈希|版本号)`** 头信息，**放入 `If-None-Match(不匹配就返回新资源)` 请求头**中，服务器根据该值判断资源是否被修改。若修改则返回新资源，若未修改则返回 `304 Not Modified(重定向，告知使用缓存)`。_【第四步，由于是下面第五步的替代方案，所以**优先级更高**】_
>
> 若第四步缓存响应中的 `ETag` 头信息不存在，浏览器会将**缓存响应中的 `Last-Modified(最后修改时间)`** 头信息，**放入 `If-Modified-Since(如果被修改就返回新资源)` 请求头**中，服务器根据该时间来判断有没有修改。修改则返回新资源，未修改则返回 `304 Not Modified(重定向，告知使用缓存)`。_【第五步：因为存在一些弊端(例如：文件修改时间格式复杂难解析)，被第四步替代，所以**优先级低**】_

---

### 浏览器存储

### 浏览器性能分析
