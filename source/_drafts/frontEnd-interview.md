---
title: 高级前端题库：你没见过的八股文都在这
date: 2024-04-12 11:17:42
updated: 2024-04-12 11:17:42
tags:
  - interview
categories:
  - 技术分享
---


一些你见过的...没见过的...八股文...~~实际开发中哪里会遇到这些问题呢？可能会有，但不常见。但你又不能不知道🙄🙄🙄~~

文章包括了 `css`、 `js`、 `ts`、 `node`、 `框架`、 `工程化`、 `浏览器`、 `HTTP 网络以及安全`、 `算法题`、 `项目`、`手写题` 多个维度..._不排除后面会更新其他的类型_

因为是汇总的问答篇，所以描述也并不会很详细（如果是要学习的话，鼓励去刨根问底，知其然知其所以然...）

持续更新...涨知识中...

<!-- more -->

## CSS 篇

### BFC 以及其应用

### BFC/IFC/GFC/FFC 区别

### 怪异盒模型

### CSS 预处理器

### 自适应实现

### 垂直居中的几种实现方案

## JS 篇

### 垃圾回收

概念：

- **对于开发者而言，“不再需要的”内存被称为垃圾**，而“不再需要”的定义又太过主观，这取决于开发者。`JS` 语言提供了垃圾回收器，尽管它无法断定“不再需要的”内存是否需要回收，但**对垃圾回收器而言，无法触达的内存空间（即不再可访问），它一定是垃圾，需要被回收。**
- 除了回收器**自动识别无法触达**来回收垃圾释放内存外，还可以通过**将变量或函数置为 `null`** 的方式让其之前的内存空间不可达来**触发垃圾回收**。

实现（回收器如何判断是否可触达）`GC（垃圾回收）` 算法：

`所谓的标记，其实就是在进入执行上下文时开始标记，出执行上下文时结束标记，记录存活的对象并标记`\_`

- **引用计数**：`IE9 以下`

  1. 给对象添加一个引用计数器，每当有一个地方**引用它时，计数器值就 `+1`**，当**引用失效时，计数器值就 `-1`**。任何时刻**计数器为 `0` 的对象**即表示不可能再被访问了，因此**可以回收**。

> 缺点: 当**对象循环引用时，引用次数无法标记为 `0`**，就会导致无法被回收。

- **标记清除**：`JS` （浏览器）最常用得到垃圾回收机制。
  1. 标记阶段：垃圾回收器将所有**活动对象（从根节点开始的可达对象）做上标记**，然后遍历堆中的所有对象，**清除没有标记的对象（垃圾）**
  2. 清除阶段：**清除没有标记的对象，释放内存**

> 优缺点：标记清楚法只需要记录起始和结束过程中的活动对象，所以**速度快**。然而由于清除的对象空间不连贯，在清除后并不会对空出来的空间进行整理，因此会**产生大量不连续的内存碎片**，导致无法分配较大的对象，**造成内存溢出**。

- **标记整理**：
  1. 标记阶段：同**标记清除**。
  2. 整理阶段：将所有**活动对象压缩（移动）到内存的一端**，然后**清理边界外的内存**。

> 优缺点：和标记清除相比，多了将活动对象移动到内存一端的过程，所以**速度慢**。此外**避免了不连续的内存碎片产生**，能更好的利用内存空间。

- **复制**：
  1. 将内存分为大小相等的两块`（1，2）`，每次只使用其中一块。
  2. 在垃圾回收时，将所有存活的对象`（1）`复制到未使用的那块内存`（2）`中，然后清除正在使用的内存`（1）`中所有对象。

> 优缺点：因为需要将内存一分为二，所以会**占用双倍的内存空间**，优点同标记整理，**避免了不连续的内存碎片产生**。

- **分代收集**：
  1. 把堆内存分为**新生代**和**老生代**（详细比例看不同语言实现）。
  2. **新生代**中，每次垃圾回收后，都会发现有大批对象死去，只有少量对象存活，那么就采用**复制算法**，只需要少量的内存成本就可以收集。（新生代分为**三个区：Eden、From、To**。当空间不足时会触发 `GC`，`Eden` 和 `From` 区存活的对象将复制到 `To` 区，`存活值 +1`，然后清除 `From` 区空间，再交换 `To` 区和 `From` 区，直到下一次 `GC`。存活值超过阈值`默认 15`的活动对象，放入老年代中，当**老年代空间不足先触发 `GC`**，还是不足则触发 `Full GC`，之后还不足则抛出**栈溢出**）
  3. **老年代**中，因为对象存活率高、没有额外空间对它进行分配担保，就必须使用**标记整理**算法来进行垃圾回收。

> 优缺点：根据活动对象的存活时间，采取不同的回收策略，最大化提升回收效率。

---

### 内存泄漏

概念：

- 内存泄漏是指**不再需要使用的内存，没有及时得到释放，造成的内存浪费，使程序内存占用越来越高影响性能**。

如何定位（发现）：

- `浏览器的DevTools` 提供了页面活动情况生成可视化结果，对比内存堆栈变化确认是否产生内存泄漏

解决（如何避免内存泄漏）：

- **减少不必要的全局变量，及时释放不再使用的对象**。包括但不限于 `dom 引用`、`事件监听` 等等。

- **减少闭包的使用**，至于闭包为何会造成内存泄漏，下面在闭包中详谈。

---

### 闭包的理解

概念：

- 函数嵌套函数，内部的函数就是闭包。

优缺点：

- 空间私有化，持久化内存，延长变量的生命周期。

- 可以从函数外部访问到函数内部的变量。

- 容易造成内存泄漏：
  1. 持有了不再需要的函数引用，会导致函数关联的词法环境无法销毁，从而导致内存泄漏
  2. 当多个函数共享词法环境时，会导致词法环境膨胀，从而导致无法触达也无法回收的内存空间造成内存泄漏。

如何解决闭包的内存泄漏:

- **尽量避免使用闭包**；

- **在使用完后将其置为 `null` 触发 `GC`**。

应用：

- 防抖节流函数实现，`react hooks` 实现等。

---

### New 操作符作用以及实现原理

作用：生成类的**实例对象**，或者构造函数的实例对象。

实现：

- 创建一个新对象；
- 将新对象与构造函数通过原型链关联起来；
- 将构造函数中的 `this` 绑定到这个新对象上；
- 根据构造函数返回值类型判断，如果返回值是一个对象，则正常处理，否则返回这个新对象。

模拟实现：

```js
function _new(fn, ...args) {
  const obj = {};
  obj.__proto__ = fn.prototype;
  const result = fn.apply(obj, args);
  return result instanceof Object ? result : obj;
}
```
---

### 如何确保构造函数只能通过 new 调用

- 通过判断 this(new 调用时会指向实例) 是否为当前构造函数的实例(instanceof)。 **`this instanceof Fn`**
- 借助 **new.target 判断是否通过 new 调用**
- **ES6 的 class**

---

### 原型链

概念：

- 所有的**对象都有一个属性 `__proto__`**，所有的**函数都有一个属性 `prototype`**
- 对象的`__proto__` 指向其构造函数的 `prototype`。
- 构造函数的 `prototype` 本身也是一个对象（**原型对象**），它有一个属性 `constructor` 指向构造函数本身。

为什么称为原型链：

> 正是因为构造函数的 `prototype` 也是一个对象，所以它可以通过 `__proto__` 找到上层构造函数，一直向上直到为 NULL，因此就**形成了链式访问，称之为原型链**。

---

### this 理解和指向修改

_根据不同的环境以及执行上下文决定当前的 this。_

- 在浏览器全局环境中为 window，如果是别的**全局环境可以使用 `globalThis` 来获取**。

- 如果是**函数执行上下文**，判断是箭头函数还是具名（匿名）函数。
  - 如果是**箭头函数，其本身不含 this**，所以在它里面访问 this 会**向上(词法环境)查找**。
  - 如果是**具名（匿名）函数，则和它的调用者有关**。（**直接调用**指向全局 this，**对象.方法** 则指向对象，类推如果是事件绑定：**事件源.事件** 则指向事件源）

修改：

- 通过 `fn.call/fn.apply/fn.bind` 都可以修改 this 指向
- 都是通过调用时传入第一个参数来修改 this，这个参数就是新的 this
- 区别就是 call/apply 都是立即执行该函数，而 bind 则是会返回一个新的函数(如果传了函数参数，会在调用新函数时作为预置参数，排在其他参数之前)，并不会产生副作用。
- 除此之外，call/bind 除了第一个参数位置外，其他函数参数格式都是以此传入，而 apply 则是以数组形式传入。

---

### 变量提升（预解析）/暂时性死区（TDZ）、执行上下文（词法环境）、作用域链理解

**变量提升（预解析）/暂时性死区（TDZ）**:

- 在代码执行前，会经历一次**预解析**过程，会**优先进行函数/变量的声明/提升**。
- 提升后，如果在其真正**声明(实际代码位置)前访问**，会根据声明关键字不同而产生不同的表现。
  - 如果是 **`var` 则会返回 `undefined`**
  - 如果是 **`let/const` 则会报错**。（根据官方说明：这两个关键字声明的变量，在其真正**声明前的区域**访问会抛异常，这块区域**也称 `TDZ暂时性死区`**）
  - 如果是 **`function`**，则返回函数，可以正常执行（**提升过程中如果遇到同名声明**（不分先后顺序），**函数优先级最高**，即在**同名声明(代码位置)之前访问(打印)返回函数**，同名声明**之后返回新的声明值**（它俩的排列**先后顺序不影响结果**）**）

**执行上下文**：

- 又称**执行环境**。分为**全局执行上下文**和**函数执行上下文**。
  - 全局执行上下文：**在程序开始执行时创建**，只有一个，即**全局执行上下文**。
  - 函数执行上下文：**在函数被调用时创建**，每次函数调用都会产生一个新的上下文，即**函数执行上下文**。

**作用域链**：

> 作用域：分为全局作用域、局部(私有，目前只代表函数)作用域、块级作用域(`let/const` 只在这个作用域生效，一个 `{}` 就是一个块作用域)

- 所谓的作用域链，是我们在访问某个变量时，会优先在当前作用域查找。如果没有找到，则是会在上一层级的作用域进行查找(访问)，一直向上直到最顶层。

---

### 事件循环（node 和浏览器的区别）

之前写了一篇文章单独整理了。[https://flynna.github.io/share/javascript-event-loop/?t=1712848978855](https://flynna.github.io/share/javascript-event-loop/?t=1712848978855)

**为什么存在**（需要）事件循环：**`JS` 是单线程**，而有些任务需要长时间挂起，为了**避免程序被阻塞**产生同步和异步任务。事件循环就是**协调这些任务**排列处理的一种方式。

> 执行宏任务 —> 然后执行宏任务产生的微任务 —> 若微任务在执行过程中产生了新的微任务（加到队列末尾），则继续执行微任务 —> 微任务执行完毕清空 —> 下一个符合条件的宏任务进行下一轮循环…..

**node 和浏览器中的事件循环区别**:

- 前面提到的都是浏览器中事件循环的表现（**Node 在 11 版本后行为和浏览器一致**）。

- 针对 `node 环境（10 以前）`：
  - `process.nextTick()` 的优先级要高于其他微任务。而浏览器环境中是同优先级，看入队列的先后顺序
  - node环境下有六个阶段的宏任务（`timers定时器`、 `pending callback回调`， `idle，prepare 系统内部使用`， `poll 轮询`， `check 检测，setImmediate 在这个阶段执行`， `close callbacks 关闭的回调 .on('close', callback)`），执行完一个阶段的任务后，会先执行 `process.nexTick()`，然后执行微任务队列，然后执行下一个阶段任务...

---

### 继承的几种实现方式

### 模块化和模块化规范（历程）

### 防抖、节流实现

### 浅拷贝和深拷贝实现方案、手写(利用深度、广度优先分别实现)

### promise 实现原理、相关 api 手写、间隔输出实现

### promise.all 的错误处理

### es7 的 async/await 原理和实现

### 迭代器及实现原理

### Symbol、bigInt 类型了解

### map、set、weakMap、weakSet 区别

### proxy 和 reflect 常用 API 理解和使用

### 谈谈 web worker

### ES6 转为 ES5 的实现思路

### a.b 的方式 a['b'] 的方式性能对比，原因

### for 循环为什么比 .foreach 性能高 

### 数组长度为 100000，取首项和尾项的时间差距

## TS 篇

### interface 和 type 作用和区别（异同）

### 泛型的了解（内置的泛型）

### 给函数添加泛型后，调用的时候不传类型默认是什么表现（类型）

形如: `function<T>(): T {}` 或者 `function<T>(param: T) {}` 或者 `function<T = any>() {}`等等。其实他们的**表现都不太一样**。

- 当泛型 **`T` 用作函数形参的类型**时，如果不传则**根据调用时的实参推倒类型**。
- 当泛型 **`T` 没有用作形参的类型**时，如果**不传则使用默认类型**，默认类型如果没指定则是 `unknown`。
- **不会抛异常**

---

## 算法篇

### 几种排序算法的手写

### 广度优先遍历、深度优先遍历

### 反转链表

### 平衡二叉树

### 树转列表、列表转树

## 框架篇

### 列表组件中的 key 的作用：

先说结论：**方便在 diff 过程中更准确、更快的找到旧的 vNode，从而提升 diff 速度**

- `key` 可以看作是 `vNode` 的唯一键，添加了 `key` 过后，可以通过 `map` 映射更快的找到旧的 `vNode`，而非遍历查找。

- 在 `vue/react` 中都是通过 `diff` 都是通过 `diff` 算法对比新旧的虚拟节点，从而更新节点，如果当前的 `key` 没有找到映射中对应的 `vNode`，则表示新增。

- 通常可以通过修改 `key` 这种方式在数据变化时强制更新界面组件的渲染，避免组件“就地复用”的副作用。

---

### 说说 diff 算法过程

先说概念：**diff 算法是用来对比新旧虚拟 DOM 的一种算法**，对比出哪些**虚拟节点**更改了。

> 当数据变化时，会触发 `setter`，并通过 `dep.notify` 通知所有 `订阅者 watcher`，然后订阅者就会调用 `patch` 方法给真实 DOM 打补丁，更新相应的视图。

`patch` 对比流程：

- 新旧虚拟 DOM 树进行同层对比，判断当前的虚拟节点是否为**同一种类型**的节点，如果是则继续通过 `patchVnode` 深层次对比，**若不是则直接整个节点(含子节点)替换为新虚拟节点**

> 至于是否为同一种类型节点对比，会对比**标签是否相同**、**key 是否相同**、**是否都是注释节点**、**是否都定义了 data、如果是 input 那么 type 是否一致**

- 在 `patchVnode` 对比进行深层比较时，会先判断**是否为同一个虚拟节点对象**，如果是则直接终止比对，若不是则先判断**是否为文本节点且文本不一致**，是则更新文本节点内容，不是则继续比对。比对**是否都含有子节点**，若（新旧虚拟节点）其中某个有子节点某个没有，则执行真实 DOM `即 el` 子节点的新增/删除，若都有子节点，则通过 `updateChildren` 比对两者的子节点并更新。

- 对于都有子节点的虚拟节点，则是**通过 `首尾指针法（头尾交叉对比，即新旧虚拟子节点列表都有头尾两个指针，4种相互对比方式：头头/头尾/尾头/尾尾）`移动指针对比找到可以复用的旧节点**，如果**找不到，则通过 key--> index 的映射关系查找**。

_（通过了解了 diff 原理，也就明白了 key 为什么不能是 index，因为如果新元素在首项插入，那么比对过程中列表的所有的节点都将被更新，因为相同 key 位置的节点内容都错位了）_

---

### vue/react diff 算法如何优化时间复杂度的？

复杂度从 `O(n^3) --> O(n)`，该题或者可以说如何时间复杂度计算出来的？

- 在没有 key 的时候，尝试将**老树的每个节点都去遍历新树的节点，直到找到新树对应节点，此时时间复杂度是 `O(n^2)`**，对比出不同后，再计算最短修改距离修改节点，故而总复杂度为 `O(n^3)`。

- 至于优化成了 `O(n)` ，则是因为以下三个策略来降低的：**父节点不同则放弃子节点的比较，直接替换（同层对比）、子节点变化不会关心变化的是什么而是直接替换渲染、key 策略通过映射查找旧节点**

---

### SSR 原理

`SSR（server side render 服务端渲染）`，参考：[https://github.com/yacan8/blog/issues/30](https://github.com/yacan8/blog/issues/30)

**Demo:** [https://github.com/yacan8/vue-ssr-demo](https://github.com/yacan8/vue-ssr-demo)

**SSR 优势**：

- 最早的服务端渲染是数据变化就会重新渲染整个页面，同时前后端代码并没有分离，维护相对困难。
- SPA 单页面应用虽然避免了这个缺点并在客户端请求资源渲染，但是缺并**不利于 SEO (Search Engine Optimization 搜素引擎优化)**。其实也就是不方便爬虫爬取，部分**低级爬虫**是**无法爬取通过 `js` 脚本渲染的页面**资源。。
- 资源获取都通过客户端请求，导致首屏加载时间变长
- 为了解决这些问题，SSR 服务端渲染再次出现了（不是最早的服务端渲染方案）。

**SSR 缺陷**:

- 开发成本提高（需要熟悉nodeJs，复杂的工程配置）
- 更高的服务器负载均衡（服务器增加了 html 渲染，提高了 CPU 占用）
- 需要 Nodejs 运行环境，不能直接部署到静态文件服务器

原理：

- **同构项目**，即路由、数据模型、模板组件在两端共享。（同构项目：让代码既能直接在客户端渲染，也能在服务端进行渲染）
  模板组件同构：
  - **分环境编译**：根据编译产出的环境不同，`将 webpack 打包配置分为两份`（`.client.config/.server.config`）、根据 **`cross-env` 分环境配置进行打包**
  - 入口处 **vue 实例初始化兼容**。分环境编写 vue 实例初始化代码（入口文件）
  - 服务器入口引入前面打包的 `webpack 构建结果（client-bundle 和 server-bundle）`
  - 利用 `vue-server-render` 插件提供的 `createBundleRender` **创建 `html 渲染器`**。
  - 服务端配置客户端构建的静态文件访问，并挂起全部路由请求，返回由上一步生成的`渲染器renderer` 生成的 html `renderer.renderToString(context, (err, html) => res.send(html))`

  路由同构：
  - 前面我们挂起了所有的路由请求，全部交给 vue 处理。所以需要在挂载实例(entry)的时候分别添加路由匹配
  - 修改客户端路由（同常规 spa，并挂载到实例）、修改 server-entry(export default (context) => return app)，通过 `context.url（server挂起路由的位置传入的当前 req.url`） 读取路由，并完成 `router.push(server 创建实例时会拿 router)`。

  数据模型同构:
  - 客户端 vuex.store 正常创建，同spa
  - 将该值**绑定到 context.state 上**，在服务端渲染时**会序列化到 window.__INITIAL_STATE__**
  - 修改client-entry，并将上面**序列化的值激活（同步）到 store**（`store.replaceState(window.__INITIAL_STATE__`)）

为什么没有传统的服务端渲染弊端（不同）？

- 本质上除了一些固定的配置项，实际的项目开发和客户端是一套代码（保留了 SPA 和 SSR 的各自的优点）。_尽管如此，还是需要权衡再使用_

---

### vue 如何实现数据劫持

### vue2/3 响应式（双向绑定 v->m/m->v）原理

### 虚拟 dom 真的比真实 dom 快吗？（看法）

### redux 和 vuex 的设计思想

### vue 中子组件和父组件同时存在，此时父子组件的整体生命周期顺序

### vuex 的 mutation 和 react 的 reducer 为什么不能做异步操作

### react-router 中的 Link 和 a 标签的区别

### react 中 reducer 为什么是纯函数？

### react Fiber 架构作用和原理

### react 事件机制原理

### react 常用 hooks 使用以及实现原理

### react setState 什么时候同步，什么时候异步？立即打印的输出结果？同情况下 vue 的表现？

> 由于 `vue 会对数据的变化做劫持`，所以不管如何操作数据，当被访问的时候都 **`是最新的，是同步（并将多个同步合并【变更同步，更新渲染异步】，只 render 一次）`**

react 的同步/异步时机：

- 同步：通过 **js原生api 包裹的 callback**都是同步执行（执行几次 `setState` 就 `render` 几次）
  - **promise.then(callback)**
  - **setTimeout(callback)**
  - **addEventListener(eventName, callback)**
  - **上面 callback** 内执行的 `setState`（此时 **react 无法控制**），就是**同步**的，每次都是**最新值**。

- 异步：react 控制的 `合成事件 onClick、hooks、生命周期` 内直接调用 `setState` 都是异步的。
  - **onClick function**
  - **useEffect function...**
  - **上面 function** 内执行的 `setState` 都是异步的，每次都是**旧值**，**不会立即变更**。
  - 解决办法：如果需要多次执行 `setState`，则通过回调更新，如果需要使用新值，则不通过 `state` 获取。

---

### react useState 为什么不能在 if 语句中使用？

### react useEffect 的第二个参数传和不传的区别?

### react useEffect 以及其 return 的函数调用顺序

### react useEffect 获取 setState 的新数据

### react HOC / Render Props / Hooks 作用和区别

### vue/react 组件之间的通信方式

### vue 和 react 的区别

### vue3 新特性

### react18 新特性

### react 性能优化方案

## NodeJS 篇

### npm 安装模块的机制（为什么可以自动安装）

### 中间件的实现

### 文件读写

### 流和管道

### NestJS `守卫（guard）`和 `过滤器（filter）` 实现

### sql 的基础增删改查

### token 加密实现

### 统一用户中心实现原理

### RESTful 接口规范理解

- 标准的 http 请求方法（GET/POST/DELETE/PUT..）和响应状态码
- 响应足够详细
- 所有的资源都有唯一标识符(url)，根据请求资源添加合适的缓存机制，提升性能

## 项目篇

### 大文件的断点续传

### 如何处理输入框中中文输入的防抖

### 实现模糊搜索结果中的关键词高亮显示

### 如何判断输入框中输入的是正确的网址

### 如何减少白屏时间

### 谈谈项目优化方案

## 工程化篇

### 微前端方案

### lerna 和 yarn workspace 使用，以及两者差别

### lerna 发布过程中的异常处理

### 谈谈代码测试实施

### Babel 的原理

### webpack 的 plugins 和 loaders 区别

### webpack 打包优化

### webpack 热更新原理

### webpack 打包原理（流程）

### webpack 和 rollup 对比

## 网络篇

### http 和 https 的区别

- **安全性**：`http` 是明文传输，有被**截获篡改**的风险；`https` 是基于 `ssl`协议的**加密传输**，**更加安全可靠**。
- **证书**：`https` 需要 `CA` （证书颁发机构）颁发的证书进行加密和解密操作。因此在使用 https 时需要配置证书，http 则不需要。
- **端口**：`http` 默认端口是 **`80`**，`https` 默认端口是 **`443`**。

---

### https 的加密算法、秘钥交换原理

### https 中间人攻击

### http 长连接 和 tcp 长连接（区别）

**HTTP 长连接**：

- HTTP 1.1 默认开启，1.0 默认关闭
- 在请求 header 头上添加 `Connection: Keep-Alive`，服务端收到请求后会在响应头中添加 `Connection: Keep-Alive`，保证连接不中断。
- 如果需要关闭 `keep-alive` 则在请求头里添加 `Connection: close`（一般会在服务上配置长连接的超时时间（可以理解为使用了防抖）：`keepalive_timeout`，超过了这么长时间没有新请求将关闭）

**TCP 长连接**：

`TCP 的 Keepalive` 就是**一种保活机制**： 

- 客户端和服务端建立连接后，如果**长时间没有数据交互**，会**触发保活机制**。
- 向对端发送保活的探测报文看**是否响应正常**（正常的话时间就重置，和前面提到的防抖处理差不多）。
- 如果**对端主机崩溃**（或者其他原因**导致报文不可达**），会**多次尝试**（超过探测阈值时**判断 TCP 连接死亡**）。

> 保活机制**默认是关闭**的，需要通过设置相应的配置参数才能使用。(通过 `socket` 接口设置 `SO_KEEPALIVE`)


### http1.0/1.1 和 http2.0 区别

- `1.0`

  - 不支持断点续传
  - 默认不保持长连接，每次请求都需要重新建立连接（如果需要，将其设为 close 外的其他值）
  - 只支持 `Get/Post` 请求方法
  - 仅有 **`If-Modified-Since（只能用于 Get/Post）、Expires`控制缓存**。`96 年`引入，是最基础的协议。

- `1.1` 在 `1.0` 的基础上：

  - 支持 **`keep-alive` 长连接，每次连接支持多次请求发送**
  - 支持**断点续传**(请求头 `Range` 实现)
  - 引入了其他**标识（`E-tag、If-Unmodified-Since、If-Match、If-None-Match`）来控制缓存**是否失效
  - 此外**支持更多的 `RESTful 风格` 的请求方法**，如 `PUT/DELETE等`。`99 年`提出。

- `2.0` 在 `1.1` 基础上：
  - 支持`header` **头部压缩**【`HPACK` 算法】 （由于`1.1`以后头部通常会放很多的标识符导致头部偏重，存在高占用问题）
  - 此外使用了更靠近 `TCP` 的二进制格式而非 `ASCLL` 码，提升了解析效率。
  - **`2.0 强调安全理念，所以通常用于 https，会更加安全`** ，`15 年` 提出。

---

### http2.0 的多路复用

### http 的无状态

`无状态协议(Stateless Protocol)` 就是指**浏览器对于事务的处理没有记忆能力**

结论：严格意义上来说，在 `http1.1/1.0` 是无状态的。`http2.0` 由于存在 `GOAWAY` 消息和握手，是可以算作有状态的（社区争议）。

原因：

- 在 `http1.1` 之前，每次请求都需要建立 `TCP` 连接（三次握手），而且每次请求都包含了所需要的完整数据，不涉及状态变更。即使是 `http1.1` 支持了 `keep-alive` 长连接，允许一次连接发送多个请求，它也并没有改变这个结果（**无记忆：不会在服务端保存任何浏览器的信息**）。

> [`https://github.com/lgwebdream/FE-Interview/issues/1213`](https://github.com/lgwebdream/FE-Interview/issues/1213)

解决方案：

- 正因为 `http` 的无状态，**`cookie` 应运而生**。

> `client` 发送请求后，由 `server` 设置响应头（`set-cookie`），`client` 会保留 `cookie`，之后的请求都会附带 `cookie` 头部信息。
>
> 但是 `cookie` 可存储内容有限，直接暴露在浏览器也存在一定的**泄漏风险**，所以就需要**使用 `session` 在服务器存储**相关用户信息。

- 为了将 `session` 中的内容与访问的 `client` 挂钩，通常会通过 `sessionId` （中存在 `cookie`）进行标识。

> 存到 `session`，用户多了以后会增大开销，为了提升效率，需要做分布式和负载均衡（后端完成）

- **`sessionId` 中存有 `cookie`**，仍**有被伪造的风险**（`CSRF`），为了保护这些信息，通常会**使用 `token` 来鉴权**，用于验证 `client` 身份。

---

### http 状态码

<div>

> 1：请求收到，继续处理

> 2：操作成功收到，分析、接受

> 3：完成此请求必须进一步处理

> 4：请求包含一个错误语法或不能完成

> 5：服务器执行一个完全有效请求失败

> 100——客户必须继续发出请求

> **101——客户要求服务器根据请求转换 HTTP 协议版本，服务器同意了**

> **200——交易成功**

> 201——请求被成功处理，并已完成资源创建（通常用于 POST）

> 202——收到请求、但还未进行处理

> 203——返回信息不确定或不完整

> 204——请求收到，但返回信息为空

> 205——服务器完成了请求，用户代理必须复位当前已经浏览过的文件，**通知客户端刷新页面更新资源**

> 206——服务器已经完成了部分用户的 GET 请求

> 300——请求有多种可能的响应。

> 301——请求的资源被**永久**重定向，重定向的地址为 HTTP 响应头（Location）指定的 URL

> 302——请求的资源被**暂时**重定向，重定向的地址为 HTTP 响应头（Location）指定的 URL

> 303——重定向，通常为 PUT 或 POST 操作的返回结果。

> **304——请求资源无变化，可以通过缓存获取。客户端已经执行了 GET，但文件未变化**

> 305——请求的资源必须从服务器指定的地址得到

> ~~**306——前一版本 HTTP 中使用的代码，现行版本中不再使用**~~

> 307——申明请求的资源临时性删除

> **400——错误请求，如语法错误**

> 401——请求授权失败

> 402——保留有效 ChargeTo 头响应。**保留的状态码，实际没有浏览器支持**

> **403——请求不允许。**一般用于权限不够获取该资源的时候使用

> **404——找不到相关资源。没有发现文件、查询或 URl**

> **405——用户当前的请求 http 方法不允许**

> 406——根据用户发送的 Accept 拖，请求资源不可访问

> **407**——类似 401，用户必须首先在**代理服务器上得到授权**

> 408——客户端没有在用户指定的饿时间内完成请求

> 409——对当前资源状态，请求不能完成

> 410——服务器上不再有此资源且无进一步的参考地址

> 411——服务器拒绝用户定义的 Content-Length 属性请求

> 412——一个或多个请求头字段在当前请求中错误

> 413——请求的资源大于服务器允许的大小

> 414——请求的资源 URL 长于服务器允许的长度

> 415——请求资源不支持请求项目格式

> 416——请求中包含 Range 请求头字段，在当前请求资源范围内没有 range 指示值，请求也不包含 If-Range 请求头字段

> 417——服务器不满足请求 Expect 头字段指定的期望值，如果是代理服务器，可能是下一级服务器不能满足请求

> **500——服务器产生内部错误**

> 501——服务器不支持请求的方法

> 502——网关或代理的服务器，从上游接收的响应是无效的

> **503——服务器过载或暂停维修，暂时不可用**

> **504——响应超时**。关口过载，服务器使用另一个关口或服务来响应用户，等待时间设定值较长

> **505——服务器不支持或拒绝支请求头中指定的 HTTP 版本**

</div>

---

### TCP 和 UDP 的区别

**都是位于计算机网络模型中的传输层协议。**

区别：

- **UDP** 无需握手建立连接，从而低延迟速度快、支持大数据包发送，允许 DNS 查找、是无连接协议。
- **TCP** 通过**握手挥手**确保连接的建立和关闭，所以速度会比较慢、支持错误重传，更加可靠、是面向连接的协议。

### TCP/IP 三次握手和四次挥手

概念：**`TCP` 是可靠的面向连接、字节流、传输层的协议/服务**。在客户端和服务器两端的内存中分别记录一些信息，比如 `IP`、端口等。通过三次握手过程在客户端和服务端建立连接，通过四次挥手来关闭连接（双工关闭，需要两边都确认以及发送关闭请求）。

- **三次握手**(开始)

  - 客户端向服务器发送 `SYN` 报文，并指明客户端的初始序列号`(INS c)`
  - 服务器收到客户端的 `SYN` 报文，向客户端发送自己的 `SYN` 报文，并指定确认的 `ACK(INS c+1)`，同时指明自身的初始序列号 `(INS d)` (得出结论：客户端发送正常，服务器接收正常)。
  - 客户端收到服务器的 `SYN` 报文，向服务器发送 `ACK(INS d+1)` 确认码(得出结论：服务器发送正常，客户端接收正常)。

- **四次挥手**(结束)

  - 当主机 `A` 完成数据传输后，提出停止 `TCP` 连接的请求。
  - 主机 `B` 收到作出响应，确认 `TCP` 连接将关闭。
  - 由 `B` 端再提出反方向的关闭请求。
  - 主机 `A` 对主机 `B` 的请求进行确认，**双方向的关闭**结束。

> **主机会在挥手结束，两个单位时间后才断开连接，防止服务器会突然发送其他请求**。避免最后的 `ACK` 丢失而导致另一方不断重传 `FIN`。

---

### Get 和 Post 区别

两者都是前端 `http` 请求中比较常用的请求方法。

- 类型： `Get`通常用作资源的获取，Post 一般用于资源提交，所以前者传输速度相对更快。

- 安全性：`Get` 是通过 `query` 的方式传输参数，直接暴露在请求链接中，容易被窃取；`Post` 通常用请求体 `Body` 传输参数，更加安全。

- 长度限制：`Get` 请求由于参数都放到了 `URL` 中，所以需要严格限制`URL` 的长度；`Post` 请求由于参数通常都在请求体中，说无限制也不为过。

- 缓存：`Get` 请求内容会被浏览器主动 `cache`，同时参数会保留在浏览器历史记录； `Post` 默认不会。此外 `GET` 在浏览器回退时是无害的，而 `POST` 会再次提交请求。

- 请求编码：`GET` 请求只能进行 `url` 编码，而 `POST` 支持多种编码方式。

- 参数类型：`GET` 只接受 `ASCII` 字符，而 `POST` 没有限制。

- 时机：`GET` 请求浏览器会将 `header、data` 一起发送出去，服务器响应 `200`；`Post` 请求浏览器先发送 `header`，服务器响应 `100 continue`，浏览器再发送 `data`，服务器响应 `200 ok`（**火狐浏览器除外**）。**`Post` 发两次数据包的原因：第一次检测服务器是否能够正常应答**

> 像在浏览器地址栏中输入链接访问、标签中的链接，其实都是一次 `Get` 请求

---

### ajax(xhr) 和 fetch 区别

`ajax` 是概念，`axios` 是封装，`xhr 和 fetch（es6，基于 promise 实现）` 是实现。

区别：

---

### XSS 攻击和 XSRF 攻击（前端安全）

### cookie 和 token 都存放在 header 中，为什么 token 不会被劫持？

- **防止 CSRF**。主要是**因为 `cookie`** 在每次请求时都会**被浏览器自动携带**，**容易被 CSRF 攻击**，而浏览器不会自动携带 `token`。

> `CSRF`: 用户网站登陆-攻击者网站-攻击者请求用户网站的方式

### SSE 和 websocket 区别

## 浏览器篇

### 渲染原理和性能提升

> `当浏览器进程获取到 HTML 的第一个字节开始，会通知渲染进程开始解析 HTML，将 HTML 转换成 DOM 树，并进入渲染流程。`

原理：

- **浏览器通过请求得到一个 `HTML` 文本**

- **渲染进程解析 `HTML` 文本，将元素转换为 `DOM` 节点，从而构建 `DOM 树`**

> 过程：转换（原始字节根据编码转换为字符）、分词（根据 HTML 规范将字符串转为元素标记）、语法分析（将元素转为对象）、DOM 构造（将元素对象转为具有层级结构的 DOM 树）

- 如果遇到内联样式或者样式脚本，**`CSS 解析器` 解析样式规则并构建 `CSSOM 树`**；若遇到 `script` 脚本，则网络线程下载脚本并解析执行。

- **`DOM 树`和 `CSSOM 树`构建完成后，渲染进程将两者合并成`渲染树 Render Tree`**

- `渲染进程`开始`对渲染树`进行`布局`，生成`布局树 Layout Tree`（**计算所有元素位置和大小**）

- `渲染进程`对布局树进行**绘制**，生成绘制记录

- `渲染进程`的对布局树进行分层，分别栅格化每一层，并得到合成帧

- 渲染进程将**合成帧**信息发送给 `GPU 进程` **(渲染)显示**到页面中

性能提升：

- 保证渲染流程不被阻塞（办法：`script 添加 defer(等到 DOM 解析完成后执行，然后触发 DOMContentLoaded)` 属性，或者将脚本代码放至 `Body 结束标签`之前，在最后才执行 `JS`）。**`async 和 defer 类似`**，可以看作是**完全独立的脚本**（**不会等待**别的 `JS` 加载执行 or `Dom` 解析）

- **避免**不必要的绘制计算和**重排**(位置大小字体等改变)**重绘**(含前者，还包括颜色背景)

> **优化影响渲染速度**的资源：css 和 js 尽量不内联，css 放头 js（添加 defer 和 async） 放尾部

- **`GPU` 硬件加速**

---

### 浏览器的重排重绘

### 浏览器跨域的原因以及解决方式

跨域产生的原因：**浏览器的同源策略**

- 浏览器安全策略，保障非同源资源之间数据访问的安全性，默认不允许非同源的资源直接访问。

- 同源：**协议、域名、端口**完全一致，只要三个中有任何一个不一致，则非同源。

解决方案：

- **`CORS` 跨域**。全称 `cross-origin resource sharing`，由头端配置默认允许访问的域响应头（`CORS` 注解）。eg.'Access-Control-Allow-Origin:http://localhost:5500'(安全信较低)

- **`JSONP` 跨域**。由于是通过 **`scr`** 的方式（**开放性原则**）传入地址，所以**只能发起 GET 请求**，同时需要后端协作。

> 前端定义一个全局函数，后端返回函数的调用的字符串`fn()`，前端拿到这个字符串以后就会当成 `js` 代码区执行。

- **proxy 代理跨域**。服务器之间不存在跨域问题，所以可以从自己的服务器去访问别人的服务器，从而实现跨域。（**依赖同源的服务端对请求做一个转发处理，使之成为同源请求**）

### LocalStorage 和 SessionStorage 跨域

> `LocalStorage` 和 `SessionStorage` 同样受到同源策略的限制。而跨域读写的方式可以使用 `postMessage`

### 浏览器输入 url 到页面展示过程

- 浏览器输入地址比如 `http://www.xx.com`，根据域名和端口号通过 `DNS` 解析成 `IP` 地址。
- 根据 `IP` 地址以及端口号找到对应的服务器`（http 默认端口是 80，https 默认端口 443）`
- 通过 `TCP` 协议三次握手创建连接。（四次挥手关闭连接）
- 服务器接收到来自前端的请求，分配到对应路由处理，决定返回的资源（一般后端找不到对应服务时，会重定向返回 `index.html`）
- 客户端收到资源，完成后续处理（如果是页面，则解析渲染，然后根据页面标签（`link、script`等向服务器发请求...））

---

### 浏览器(`HTTP`)缓存

- **概念**：浏览器缓存是在本地磁盘存储的网络请求的资源副本，以便下一次访问时重复使用。

- **好处**：避免重复的资源传输，节省通信流量和通信时间，降低服务器压力，提升网页加载速度。

- **策略**：**强缓存**（不询问，直接使用本地缓存）、**协商缓存**（询问服务器缓存是否还有效，是否能继续使用）

`尽管协商缓存同样是一次请求询问的过程，但是如果缓存有效，就只会返回 304 状态码，因此传输会非常小。`

> 流程：
>
> 浏览器在发起请求之前，先判断是否存在该资源缓存（**该缓存不存在就直接向服务端发请求**）
>
> 若存在缓存资源先根据**头信息中的 `expires(过期时间)/cache-control(优先级更高，记录了缓存方式和过期时间)`**，**判断资源是否过期（是否要发请求）** `cache-control: public/private(仅客户端)/no-cache(协商，默认)/no-store(两种方式都不)/max-age(过期时间，秒)`
>
> 若符合上面说的条件（**缓存有效**），则直接使用缓存内容**强缓存**。若**不符合（失效）**则需要**询问服务器**缓存能否继续使用（**协商缓存**）。
>
> 浏览器将**缓存响应中的 `ETag(服务端生成的随机数|哈希|版本号)`** 头信息，**放入 `If-None-Match(不匹配就返回新资源)` 请求头**中，服务器根据该值判断资源是否被修改。若修改则返回新资源，若未修改则返回 `304 Not Modified(重定向，告知使用缓存)`。_【第四步，由于是下面第五步的替代方案，所以**优先级更高**】_
>
> 若第四步缓存响应中的 `ETag` 头信息不存在，浏览器会将**缓存响应中的 `Last-Modified(最后修改时间)`** 头信息，**放入 `If-Modified-Since(如果被修改就返回新资源)` 请求头**中，服务器根据该时间来判断有没有修改。修改则返回新资源，未修改则返回 `304 Not Modified(重定向，告知使用缓存)`。_【第五步：因为存在一些弊端(例如：文件修改时间格式复杂难解析)，被第四步替代，所以**优先级低**】_

---

### 浏览器存储

### 浏览器性能分析

### history/hash 路由，SPA 中的路由切换原理(无刷新操作)
